/* 
========================================
GameAssist — Roll20 API Script
Version: 0.1.5
Last Updated: 2025-09-25 (America/Detroit)
Author: Mord Eagle
License: MIT (see repository LICENSE)
Homepage: https://github.com/Roll20/roll20-api-scripts (submission target)

DESCRIPTION
GameAssist is a small framework for organizing Roll20 API modules with a safe task queue,
watchdog, config/state helpers, and consistent logging. This package ships with six modules:
• ConfigUI — GM-only chat controls for toggling modules and boolean options.
• CritFumble — Detects natural-1s on selected rolltemplates and offers fumble/confirm menus.
• ConcentrationTracker — Runs concentration checks (normal/adv/dis), whispers results, toggles marker.
• NPCManager — Tracks NPC death markers based on bar1 HP.
• NPCHPRoller — Rolls NPC HP from `npc_hpformula` and writes to bar1 (value/max).
• DebugTools — Optional GM diagnostics (dry-run by default) for damage, markers, and save rolls.

INSTALL / USAGE (One-Click or Manual)
• One-Click: install “GameAssist”. (Make sure “TokenMod” is also installed; see Dependencies.)
• Manual (Pro): paste this entire file into the API Scripts editor and Save.

CORE COMMANDS (GM):
• !ga-config list                          — write config handout “GameAssist Config”
• !ga-config modules                       — list modules + status
• !ga-config set <Module> key=value        — set module config (JSON/number/bool supported)
• !ga-config get <Module> key              — echo module config value
• !ga-config ui / !ga-config-ui            — open the GM chat control panel
• !ga-enable <Module> / !ga-disable <Module>
• !ga-status                               — show metrics + listeners
• !ga-debug <action>                       — run DebugTools helpers (`damage`, `marker`, `save`)

MODULE COMMANDS:
• CritFumble:
    !critfail                               — GM menu to trigger fumble UI for a player
    !critfumble help                        — help
    !critfumble-<melee|ranged|thrown|spell|natural>
    !confirm-crit-martial   | !confirm-crit-magic
• ConcentrationTracker (players/GM):
    !concentration [--damage N] [--mode normal|adv|dis] [--off|--status|--last|--config randomize on|off]
    !cc (alias)
• NPCManager (GM):         !npc-death-report
• NPCHPRoller (GM):        !npc-hp-selected    |   !npc-hp-all
• ConfigUI (GM):           !ga-config ui [--page N] | !ga-config-ui
• DebugTools (GM-only):    !ga-debug damage|marker|save [flags] (module disabled by default)

DEPENDENCIES
• TokenMod — required for marker/status changes issued by NPCManager and ConcentrationTracker.

CONFIGURATION NOTES
• Global flags (in code): GameAssist.flags.DEBUG_COMPAT, GameAssist.flags.QUIET_STARTUP.
• Per-module config via !ga-config set; types: boolean, number, JSON object/array, string.

COMPATIBILITY / FOOTPRINT
• Namespaced under global `GameAssist`. Avoids polluting global scope otherwise.
• Uses standard events: `on('ready')`, `on('chat:message')`, and graphic change events.
• Writes only to Roll20 objects documented in script.json: handout notes, token bars/markers.

SUPPORT / HELP
• Use !ga-status for quick health; !ga-config list creates a “GameAssist Config” handout.
• For bug reports, include the console whisper output from `GameAssist.log(...)`.

HEADER REQUIREMENTS NOTE
Per the Roll20 API repo contribution guidelines, this header provides name, version, last updated,
description, syntax/commands, and configuration pointers near the top of the script. 
========================================
*/

// --- MECHSUITS BANNER (YAML) ---
// mechsuit:
//   codename: "GAMEASSIST_GAMEASSIST"
//   purpose: "Roll20 API modular kernel and bundled modules (CritFumble, NPCManager, ConcentrationTracker, NPCHPRoller). This file adds MECHSUITS framing (sections, policy, notes) without changing runtime behavior. Non-goals: sheet-specific integrations or transport changes beyond Roll20 chat API."
//   order: ["app","policy","imports","utils","core.queue","core.state","compat","core.object","interfaces.commands","interfaces.events","modules","bootstrap"]
//   env:
//     required: []
//     optional: []
//     secrets: []
//   data_class: "Internal"
//   ai_data: "internal_redacted"
//   observability:
//     logs: "roll20_whisper_to_gm"
//     metrics: [{ name: "gameassist.queue.task_duration_ms", unit: "ms" }]
//     spans: ["[GAMEASSIST_GAMEASSIST:CORE:QUEUE]","[GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE]"]
//   performance: { throughput_ops: 1, latency_p99_ms: 1000 }
//   concurrency: { model: "Serialized task queue", idempotency: "N/A (event-driven)" }
//   compatibility: { accepts: ["Roll20 API sandbox (2025-04-09 build or later)"], emits: "Roll20 chat whispers/logs" }
//   policy: { notes_ref: "[GAMEASSIST_GAMEASSIST:POLICY]" }
//   error_codes: ["INVALID_ARGUMENT","NOT_FOUND","CONFLICT","UNAUTHORIZED","FORBIDDEN","UNPROCESSABLE","RATE_LIMITED","TIMEOUT","UNAVAILABLE","INTERNAL"]
//   transport_map:
//     chat: "Errors are whispered to GM; status/info are whispered as structured text"
//   canonical_tree: |
//     [GAMEASSIST_GAMEASSIST]/
//     ├─ [GAMEASSIST_GAMEASSIST:APP]
//     │  ├─ [GAMEASSIST_GAMEASSIST:POLICY]
//     │  ├─ [GAMEASSIST_GAMEASSIST:APP:IMPORTS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:APP:UTILS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:QUEUE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:STATE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:COMPAT]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:OBJECT]
//     │  ├─ [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER]
//     │  └─ [GAMEASSIST_GAMEASSIST:BOOTSTRAP]
// --- prose banner ---
// Guarantee: This is a structural wrap of GameAssist v0.1.3 for Roll20 — it reorganizes the file into MECHSUITS sections with notes and policy while preserving all code and behavior.
// Secrets: none. Logs whisper to GM. Refusal: this file does not alter module logic, transport semantics, or sheet-specific behavior; those are out of scope here.

// =============================
// === GameAssist v0.1.3 ===
// === Author: Mord Eagle ===
// =============================
// Released under the MIT License (see https://opensource.org/licenses/MIT)
//
// Copyright (c) 2025 Mord Eagle
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// =============================================================================
// [GAMEASSIST_GAMEASSIST:APP] BEGIN
// Section Title: GameAssist — Roll20 API micro‑kernel with modules (wrapper)
// -----------------------------------------------------------------------------
// mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "APP", title: "Wrapper",
//   guarantees: ["Framed sections only; original behavior intact"],
//   depends_on: [], version: "1.0.0" }
// -----------------------------------------------------------------------------

(() => {
    'use strict';

    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:POLICY] BEGIN
    // Section Title: Tunables & flags (non‑behavioral framing)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "POLICY", title: "Tunables",
    //   guarantees: ["Documented timeouts; do not change values here from legacy"],
    //   version: "1.0.0" }
    // -------------------------------------------------------------------------
    // NOTE: We declare canonical names mirroring legacy constants; values remain identical.
    //       Changing these would alter behavior; out of scope for this structural wrap.
    // --- Notes & Comments ---
    // CHOICE: Keep constants inline with legacy names to avoid breaking changes.
    // ALT: Refactor to POLICY object and import; REJECTED for now (no behavior change rule).
    // [GAMEASSIST_GAMEASSIST:POLICY] END
    // =============================================================================

    const VERSION      = '0.1.5';
    const STATE_KEY    = 'GameAssist';
    const MODULES      = {};
    const _transitioning   = {};
    let   READY        = false;
    const METRIC_HISTORY_LIMIT  = 50;
    const METRIC_DURATION_LIMIT = 20;

    MODULES.Core = {
        internal:    true,
        initFn:      () => {},
        teardown:    null,
        enabled:     true,
        initialized: true,
        active:      true,
        events:      [],
        prefixes:    [],
        wired:       true,
        dependsOn:   []
    };

    // ————— QUEUE + WATCHDOG —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:QUEUE] BEGIN
    // Section Title: Serialized task queue + watchdog
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:QUEUE", title: "Queue",
    //   guarantees: ["Single in‑flight task; watchdog resets hung jobs"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    let _busy      = false;
    let _lastStart = 0;
    const _queue            = [];
    const DEFAULT_TIMEOUT   = 30000;
    const WATCHDOG_INTERVAL = 15000;

    function _enqueue(task, priority = 0, timeout = DEFAULT_TIMEOUT) {
        _queue.push({ task, priority, enqueuedAt: Date.now(), timeout });
        _queue.sort((a,b) => b.priority - a.priority || a.enqueuedAt - b.enqueuedAt);
        _runNext();
    }

    function _runNext() {
        if (_busy || !_queue.length) return;
        const { task, timeout } = _queue.shift();
        _busy = true;
        _lastStart = Date.now();

        const timer = setTimeout(() => {
            GameAssist.log('Core', `Task timed out after ${timeout}ms`, 'WARN');
            _busy = false;
            _runNext();
        }, timeout);

        Promise.resolve()
            .then(task)
            .catch(err => GameAssist.log('Core', `Error in task: ${err.message}`, 'ERROR'))
            .finally(() => {
                clearTimeout(timer);
                _busy = false;
                const duration = Date.now() - _lastStart;
                GameAssist._metrics.taskDurations.push(duration);
                if (GameAssist._metrics.taskDurations.length > METRIC_DURATION_LIMIT) {
                    GameAssist._metrics.taskDurations.shift();
                }
                GameAssist._metrics.lastUpdate = new Date().toISOString();
                recordMetric('task', { duration, noHistory: true });
                _runNext();
            });
    }

    setInterval(() => {
        if (_busy && Date.now() - _lastStart > DEFAULT_TIMEOUT * 2) {
            GameAssist.log('Core', 'Watchdog forced queue reset', 'WARN');
            _busy = false;
            _runNext();
        }
    }, WATCHDOG_INTERVAL);
    // --- Notes & Comments ---
    // Decision log:
    //   CHOICE: FIFO with priority bump via sort; simple and sufficient for sandbox.
    //   CHOICE: Watchdog at 2× DEFAULT_TIMEOUT; mirrors legacy behavior.
    // [GAMEASSIST_GAMEASSIST:CORE:QUEUE] END
    // =============================================================================

    // ————— HANDLER TRACKING —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS] BEGIN
    // Section Title: Roll20 on/off wrappers and handler registry
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "INTERFACES:EVENTS", title: "Handlers",
    //   guarantees: ["Track listeners for safe enable/disable"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    globalThis._handlers = globalThis._handlers || {};
    const originalOn  = typeof globalThis.on  === 'function' ? globalThis.on  : null;
    const originalOff = typeof globalThis.off === 'function' ? globalThis.off : null;

    globalThis.on = (event, handler) => {
        globalThis._handlers[event] = globalThis._handlers[event] || [];
        globalThis._handlers[event].push(handler);
        if (typeof originalOn === 'function') {
            return originalOn(event, handler);
        }
    };

    globalThis.off = (event, handler) => {
        if (!globalThis._handlers[event]) return;
        globalThis._handlers[event] = globalThis._handlers[event].filter(h => h !== handler);
        if (typeof originalOff === 'function') {
            return originalOff(event, handler);
        }
    };
    // --- Notes & Comments ---
    // CHOICE: Wrap global on/off to keep a registry for teardown; avoids leaks.
    // [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS] END
    // =============================================================================

    // ————— UTILITIES —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:APP:UTILS] BEGIN
    // Section Title: Utilities (arg parsing, state helpers, audit, sanitize)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "APP:UTILS", title: "Utilities",
    //   guarantees: ["Pure helpers; no external side‑effects"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    function createMetricsStore() {
        return {
            totals: {},
            history: [],
            durations: [],
            sessionStart: new Date().toISOString(),
            lastUpdate: null
        };
    }

    function ensureStateRoot() {
        state[STATE_KEY] = state[STATE_KEY] || {};
        const root = state[STATE_KEY];

        if (!root.config || typeof root.config !== 'object') {
            root.config = {};
        }

        if (!root.metrics || typeof root.metrics !== 'object') {
            root.metrics = createMetricsStore();
        } else {
            root.metrics.totals = root.metrics.totals || {};
            root.metrics.history = Array.isArray(root.metrics.history) ? root.metrics.history : [];
            root.metrics.durations = Array.isArray(root.metrics.durations) ? root.metrics.durations : [];
            if (!root.metrics.sessionStart) {
                root.metrics.sessionStart = new Date().toISOString();
            }
        }

        state[STATE_KEY] = root;
        return root;
    }

    function getMetricsStore() {
        return ensureStateRoot().metrics;
    }

    function resetMetricsStore() {
        const root = ensureStateRoot();
        root.metrics = createMetricsStore();
        return root.metrics;
    }

    function _parseArgs(content) {
        const args = {}, pattern = /--(\w+)(?:\s+("[^"]*"|[^\s]+))?/g;
        let m;
        while ((m = pattern.exec(content))) {
            let v = m[2] || true;
            if (typeof v === 'string') {
                if (/^".*"$/.test(v))      v = v.slice(1, -1);
                else if (/^\d+$/.test(v))  v = parseInt(v, 10);
                else if (/,/.test(v))      v = v.split(',');
            }
            args[m[1]] = v;
        }
        return { cmd: content.split(/\s+/)[0], args };
    }

    function getState(mod) {
        const root = ensureStateRoot();
        root[mod] = root[mod] || { config: {}, runtime: {} };
        return root[mod];
    }
    function saveState(mod, data) {
        const root = ensureStateRoot();
        root[mod] = Object.assign(getState(mod), data);
    }
    function clearState(mod) {
        const root = ensureStateRoot();
        if (root?.[mod]) delete root[mod];
    }

    function auditState() {
        const root = ensureStateRoot();
        const whitelist = new Set(['config', 'flags', 'metrics']);

        Object.keys(root).forEach(k => {
            if (whitelist.has(k)) return;

            const mod = MODULES[k];
            if (!mod || mod.internal) {
                GameAssist.log('Core', `Unexpected state branch: ${k}`, 'WARN');
                return;
            }

            const branch = root[k];
            if (!branch?.config || !branch?.runtime) {
                GameAssist.log('Core', `Malformed state for ${k}`, 'WARN');
            }
        });
        GameAssist._metrics.stateAudits++;
        GameAssist._metrics.lastUpdate = new Date().toISOString();
        recordMetric('audit', { noHistory: true });
    }

    function seedDefaults() {
        Object.entries(MODULES).forEach(([name, mod]) => {
            if (mod.internal) return;
            const cfg = getState(name).config;
            if (cfg.enabled === undefined) cfg.enabled = mod.enabled;
        });
    }

    function recordMetric(type, { mod = null, note = '', noHistory = false, duration = null } = {}) {
        if (!type) return;

        const store = getMetricsStore();
        const totals = store.totals;
        totals[type] = (totals[type] || 0) + 1;

        const timestamp = new Date().toISOString();
        store.lastUpdate = timestamp;

        if (!noHistory) {
            const entry = { ts: timestamp, type };
            if (mod) entry.mod = mod;
            if (note !== undefined && note !== null) {
                const text = String(note).slice(0, 120);
                if (text) entry.note = text;
            }
            store.history.push(entry);
            if (store.history.length > METRIC_HISTORY_LIMIT) {
                store.history.splice(0, store.history.length - METRIC_HISTORY_LIMIT);
            }
        }

        if (typeof duration === 'number' && isFinite(duration)) {
            const durations = store.durations;
            durations.push(Math.max(0, Math.round(duration)));
            if (durations.length > METRIC_DURATION_LIMIT) {
                durations.splice(0, durations.length - METRIC_DURATION_LIMIT);
            }
        }
    }

    function _sanitize(str = '') {
        return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
    }

    function getLinkedCharacter(token) {
        if (!token || typeof token.get !== 'function') return null;
        if (token.get('layer') !== 'objects') return null;

        const charId = token.get('represents');
        if (!charId) return null;

        const character = getObj('character', charId);
        if (!character) return null;

        return { token, character };
    }
    // --- Notes & Comments ---
    // NOTE: State auditor warns about unexpected branches; no automatic deletion occurs.
    // [GAMEASSIST_GAMEASSIST:APP:UTILS] END
    // =============================================================================

    // ————— COMPATIBILITY —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:COMPAT] BEGIN
    // Section Title: Compatibility audit
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:COMPAT", title: "Compat",
    //   guarantees: ["Optional visibility of known/unknown scripts"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    const KNOWN_SCRIPTS = [
        'tokenmod.js','universaltvttimporter.js','npc-hp.js','wolfpack.js',
        'critfumble.js','rana-curse.js','statusinfo.js','npc death tracker.js',
        'customizable roll listener.js','5th edition ogl by roll20 companion.js'
    ];
    function normalizeScriptName(n) {
        return (n||'')
            .toLowerCase()
            .replace(/\.js$/, '')
            .replace(/[\s_]+/g, '-')
            .replace(/[^\w-]/g, '');
    }
    const SIGNATURES = (() => {
        const defs = [
            {
                id: 'TokenMod',
                displayName: 'TokenMod',
                aliases: ['TokenMod', 'Token Mod'],
                prefixes: ['!token-mod', '!tokenmod', '!tm'],
                events: ['chat:message', 'change:graphic:statusmarkers'],
                hints: [
                    'TokenMod drives status-marker automation; NPCManager and ConcentrationTracker expect it for marker toggles.',
                    'If TokenMod is offline, disable marker-dependent modules with !ga-disable to avoid duplicate whispers.'
                ]
            },
            {
                id: 'ScriptCards',
                displayName: 'ScriptCards',
                aliases: ['ScriptCards'],
                prefixes: ['!scriptcard', '!scriptcards'],
                events: ['chat:message'],
                hints: [
                    'ScriptCards and GameAssist both watch chat:message—keep command prefixes distinct to prevent clashes.'
                ]
            },
            {
                id: 'APILogic',
                displayName: 'APILogic',
                aliases: ['APILogic'],
                prefixes: ['!apilogic'],
                events: ['chat:message', 'change:graphic'],
                hints: [
                    'APILogic can rewrite chat commands; prefer explicit !ga- prefixes when integrating with it.'
                ]
            }
        ];
        const map = {};
        defs.forEach(def => {
            const key = normalizeScriptName(def.id);
            const match = new Set(def.aliases.map(normalizeScriptName));
            match.add(key);
            map[key] = {
                displayName: def.displayName,
                match,
                prefixes: def.prefixes.map(p => p.toLowerCase()),
                events: def.events,
                hints: def.hints
            };
        });
        return map;
    })();
    function resolveSignature(normName) {
        if (SIGNATURES[normName]) return SIGNATURES[normName];
        return Object.values(SIGNATURES).find(sig => sig.match.has(normName)) || null;
    }
    function auditCompatibility() {
        if (!GameAssist.flags.DEBUG_COMPAT) return;

        const plannedEvents   = GameAssist._plannedEvents;
        const plannedPrefixes = GameAssist._plannedChatPrefixes;
        const scriptState     = state.api?.scripts;

        if (!scriptState || !Object.keys(scriptState).length) {
            GameAssist.log('Compat', 'Sandbox did not expose external scripts; compatibility scoring limited.');
            GameAssist.log('Compat', '🔌 Events: '   + (plannedEvents.join(', ')   || 'none'));
            GameAssist.log('Compat', '💬 Commands: ' + (plannedPrefixes.join(', ') || 'none'));
            return;
        }

        const activeEntries   = Object.keys(scriptState);
        const activeNormalized = activeEntries.map(normalizeScriptName);

        const knownSet = new Set([
            ...KNOWN_SCRIPTS.map(normalizeScriptName),
            ...activeNormalized
                .map(resolveSignature)
                .filter(Boolean)
                .flatMap(sig => Array.from(sig.match))
        ]);

        const known = [];
        const unknown = [];

        activeNormalized.forEach((norm, idx) => {
            const original = activeEntries[idx];
            if (knownSet.has(norm)) {
                known.push(original);
            } else {
                unknown.push(original);
            }
        });

        GameAssist.log('Compat', '✅ Known: '  + (known.join(', ')   || 'none'));
        GameAssist.log('Compat', '❓ Unknown: ' + (unknown.join(', ') || 'none'));
        GameAssist.log('Compat', '🔌 Events: '   + (plannedEvents.join(', ')   || 'none'));
        GameAssist.log('Compat', '💬 Commands: ' + (plannedPrefixes.join(', ') || 'none'));

        const rows = [];

        activeNormalized.forEach((norm, idx) => {
            const signature = resolveSignature(norm);
            if (!signature) return;

            const prefixMatches = plannedPrefixes.filter(prefix =>
                signature.prefixes.includes(prefix.toLowerCase())
            );
            const eventMatches = plannedEvents.filter(evt =>
                signature.events.includes(evt)
            );

            const score = prefixMatches.length + (eventMatches.length * 2);
            const notes = [];

            if (signature.hints?.length) notes.push(...signature.hints);
            if (prefixMatches.length) notes.push('Shared prefixes: ' + prefixMatches.join(', '));
            if (eventMatches.length) notes.push('Shared events: ' + eventMatches.join(', '));

            rows.push({
                raw: activeEntries[idx],
                score,
                notes
            });
        });

        if (!rows.length) {
            GameAssist.log('Compat', 'No signature overlaps detected.');
            return;
        }

        rows.sort((a, b) => b.score - a.score || a.raw.localeCompare(b.raw));

        const table = [
            '| Script | Score | Notes |',
            '| ------ | ----: | ----- |',
            ...rows.map(row => {
                const noteText = row.notes.length ? row.notes.join(' · ') : 'No overlaps detected.';
                return `| ${row.raw} | ${row.score} | ${noteText} |`;
            })
        ].join('\n');

        GameAssist.log('Compat', `Compatibility hints:\n${table}`);
    }
    // --- Notes & Comments ---
    // CHOICE: DEBUG_COMPAT gate avoids noise; GM toggles as needed.
    // [GAMEASSIST_GAMEASSIST:CORE:COMPAT] END
    // =============================================================================

    // ————— CONFIG PARSER —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:STATE] BEGIN
    // Section Title: Config parser (aux to state management)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:STATE", title: "Config parser",
    //   guarantees: ["Parse JSON/boolean/number safely"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    function parseConfigValue(raw) {
        raw = raw.trim();
        if (raw === 'true')  return true;
        if (raw === 'false') return false;
        if (!isNaN(raw))      return Number(raw);
        if ((raw.startsWith('{') && raw.endsWith('}')) || (raw.startsWith('[') && raw.endsWith(']'))) {
            try { return JSON.parse(raw); }
            catch { GameAssist.log('Config', 'Invalid JSON: ' + _sanitize(raw)); }
        }
        return raw;
    }
    // --- Notes & Comments ---
    // CHOICE: Gracefully log bad JSON rather than throwing; keeps chat usable.
    // [GAMEASSIST_GAMEASSIST:CORE:STATE] END
    // =============================================================================

    // ————— GameAssist CORE —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:OBJECT] BEGIN
    // Section Title: GameAssist kernel object
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:OBJECT", title: "Kernel",
    //   guarantees: ["Logging, error handling, register/enable/disable, listener mgmt"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    const GameAssist = {
        _metrics: {
            commands: 0,
            messages: 0,
            errors: 0,
            stateAudits: 0,
            taskDurations: [],
            lastUpdate: null
        },
        _plannedEvents: [],
        _plannedChatPrefixes: [],
        _listeners: {},
        _commandHandlers: {},
        _eventHandlers: {},
        _transitioning,
        config: {},
        flags: { DEBUG_COMPAT: false, QUIET_STARTUP: true },

        log(mod, msg, level = 'INFO', { startup = false } = {}) {
            if (startup && GameAssist.flags.QUIET_STARTUP) return;

            const timestamp = new Date().toLocaleTimeString();
            const levelIcon = { INFO: 'ℹ️', WARN: '⚠️', ERROR: '❌' }[level] || 'ℹ️';

            // escape user-supplied text, then split on newlines
            const safe = _sanitize(msg).split('\n');

            // prepend /w gm to every continuation line so Roll20 treats
            // the whole block as one whisper
            const stitched = safe.map((l, i) => (i ? '/w gm ' + l : l)).join('\n');

            sendChat(
                'GameAssist',
                `/w gm ${levelIcon} [${timestamp}] [${mod}] ${stitched}`
            );
        },

        handleError(mod, err) {
            this._metrics.errors++;
            this._metrics.lastUpdate = new Date().toISOString();
            recordMetric('error', { mod, note: err?.message || String(err) });
            this.log(mod, err.message || String(err), 'ERROR');
        },

        register(name, initFn, { enabled = true, events = [], prefixes = [], teardown = null, dependsOn = [] } = {}) {
            if (READY) {
                this.log('Core', `Cannot register after ready: ${name}`, 'WARN');
                return;
            }
            if (MODULES[name]) {
                this.log('Core', `Duplicate module: ${name}`, 'WARN');
                return;
            }
            MODULES[name] = {
                initFn,
                teardown,
                enabled,
                initialized: false,
                active: false,
                events,
                prefixes,
                dependsOn,
                wired: false,
                internal: false
            };
            this._plannedEvents.push(...events);
            this._plannedChatPrefixes.push(...prefixes);
        },

        onCommand(prefix, fn, mod, { gmOnly = false, acl = [] } = {}) {
            const wrapped = msg => {
                if (!MODULES[mod]?.initialized || !MODULES[mod]?.active) return;
                if (msg.type !== 'api' || !msg.content.startsWith(prefix)) return;
                if (gmOnly && !playerIsGM(msg.playerid)) return;
                if (acl.length && !acl.includes(msg.playerid)) return;
                this._metrics.commands++;
                this._metrics.lastUpdate = new Date().toISOString();
                recordMetric('command', { mod, note: prefix, noHistory: true });
                try { fn(msg); }
                catch(e) { this.handleError(mod, e); }
            };
            on('chat:message', wrapped);
            this._commandHandlers[mod] = (this._commandHandlers[mod] || []).concat({ event:'chat:message', fn:wrapped });
        },

        offCommands(mod) {
            this._commandHandlers[mod] = [];
        },

        onEvent(evt, fn, mod) {
            const wrapped = (...args) => {
                if (!MODULES[mod]?.initialized || !MODULES[mod]?.active) return;
                if (!READY) return;
                this._metrics.messages++;
                this._metrics.lastUpdate = new Date().toISOString();
                recordMetric('event', { mod, note: evt, noHistory: true });
                try { fn(...args); }
                catch(e) { this.handleError(mod, e); }
            };
            on(evt, wrapped);
            this._listeners[mod] = (this._listeners[mod] || []).concat({ event:evt, fn:wrapped });
        },

        offEvents(mod) {
            this._listeners[mod] = [];
        },

        _clearAllListeners() {
            this._commandHandlers = {};
            this._listeners = {};
        },

        _dedupePlanned() {
            if (this._deduped) return;
            this._plannedEvents = [...new Set(this._plannedEvents)];
            this._plannedChatPrefixes = [...new Set(this._plannedChatPrefixes)];
            this._deduped = true;
        },

        _getActiveScriptNames() {
            const scripts = state.api?.scripts;
            if (!scripts) return null;
            return Object.keys(scripts).map(normalizeScriptName);
        },

        _checkDependencies(name) {
            const mod = MODULES[name];
            if (!mod) return { missing: [], verified: true };

            const deps = mod.dependsOn || [];
            if (!deps.length) return { missing: [], verified: true };

            const activeExternal = this._getActiveScriptNames();
            const missing = [];

            deps.forEach(dep => {
                const normalized = normalizeScriptName(dep);
                if (MODULES[dep]) {
                    if (!MODULES[dep].active) missing.push(dep);
                    return;
                }
                if (activeExternal && !activeExternal.includes(normalized)) {
                    missing.push(dep);
                }
            });

            const verified = activeExternal !== null || deps.every(dep => MODULES[dep]);
            return { missing, verified };
        },

        enableModule(name) {
            const mod = MODULES[name];
            if (!mod) {
                this.log('Core', `No such module: ${name}`, 'WARN');
                return;
            }
            if (mod.internal) {
                this.log('Core', `${name} is managed by the core and cannot be toggled.`, 'WARN');
                return;
            }
            if (mod.active && mod.initialized) {
                this.log('Core', `${name} already enabled`, 'INFO');
                return;
            }
            if (_transitioning[name]) {
                this.log('Core', `${name} is already transitioning`, 'WARN');
                return;
            }

            const { missing, verified } = this._checkDependencies(name);
            if (missing.length) {
                this.log('Core', `${name} requires ${missing.join(', ')}. Enable dependencies first.`, 'WARN');
                const branch = getState(name);
                branch.config.enabled = false;
                return;
            }
            if (!verified && (mod.dependsOn || []).length) {
                this.log('Core', `${name} dependency scan limited (state.api.scripts unavailable); proceeding without verification.`, 'WARN');
            }

            _transitioning[name] = true;

            _enqueue(() => {
                const m = MODULES[name];
                const finish = () => { delete _transitioning[name]; };
                if (!m) { finish(); return; }

                const branch = getState(name);
                branch.config.enabled = true;
                branch.runtime = branch.runtime || {};

                if (!m.wired) {
                    try {
                        m.initFn();
                        m.wired = true;
                    } catch (e) {
                        m.initialized = false;
                        m.active = false;
                        branch.config.enabled = false;
                        finish();
                        this.handleError(name, e);
                        return;
                    }
                }

                m.initialized = true;
                m.active = true;
                this._metrics.lastUpdate = new Date().toISOString();
                this.log(name, 'Enabled');
                recordMetric('toggle', { mod: name, note: 'enabled' });
                finish();
            });
        },

        disableModule(name) {
            const mod = MODULES[name];
            if (!mod) {
                this.log('Core', `No such module: ${name}`, 'WARN');
                return;
            }
            if (mod.internal) {
                this.log('Core', `${name} is managed by the core and cannot be toggled.`, 'WARN');
                return;
            }
            if (!mod.active && !mod.initialized) {
                this.log('Core', `${name} already disabled`, 'INFO');
                return;
            }
            if (_transitioning[name]) {
                this.log('Core', `${name} is already transitioning`, 'WARN');
                return;
            }
            _transitioning[name] = true;

            _enqueue(() => {
                const m = MODULES[name];
                const finish = () => { delete _transitioning[name]; };
                if (!m) { finish(); return; }

                if (typeof m.teardown === 'function' && m.wired) {
                    try { m.teardown(); }
                    catch(e) { this.log(name, `Teardown failed: ${e.message}`, 'WARN'); }
                }

                const branch = getState(name);
                branch.config.enabled = false;
                branch.runtime = {};

                m.active = false;
                m.initialized = false;
                this._metrics.lastUpdate = new Date().toISOString();
                this.log(name, 'Disabled');
                recordMetric('toggle', { mod: name, note: 'disabled' });
                finish();
            });
        },

        createButton(label, command) {
            const safeLabel = _sanitize(label ?? 'Button')
                .replace(/\[/g, '&#91;')
                .replace(/\]/g, '&#93;');
            const trimmed = (command || '').trim();
            if (!trimmed) {
                this.log('Core', 'createButton requires a command string', 'WARN');
                return '';
            }
            const final = trimmed.startsWith('!') ? trimmed : `!${trimmed}`;
            return `[${safeLabel}](${final})`;
        },

        rollTable(tableName) {
            const name = (tableName || '').toString().trim();
            if (!name) {
                this.log('Core', 'rollTable requires a table name', 'WARN');
                return;
            }
            const sanitized = name.replace(/[\[\]]/g, '');
            sendChat('', `/roll 1t[${sanitized}]`);
        }
    };

    GameAssist.getState = getState;
    GameAssist.saveState = saveState;
    GameAssist.clearState = clearState;
    GameAssist.getMetricsStore = getMetricsStore;
    GameAssist.recordMetric = recordMetric;
    GameAssist.getLinkedCharacter = getLinkedCharacter;

    globalThis.GameAssist = GameAssist;
    // --- Notes & Comments ---
    // CHOICE: Expose globally under same name for console and other scripts.
    // [GAMEASSIST_GAMEASSIST:CORE:OBJECT] END
    // =============================================================================

    // ————— CONFIG COMMAND —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS] BEGIN
    // Section Title: Admin/config commands (!ga-*)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "INTERFACES:COMMANDS", title: "Commands",
    //   guarantees: ["GM-gated admin commands; consistent logging"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    GameAssist.onCommand('!ga-config', msg => {
        const parts = msg.content.trim().split(/\s+/);
        const sub   = parts[1];
        if (sub === 'list') {
            const ts   = new Date().toLocaleString();
            const ver  = `v${VERSION}`;
            const cfgRoot = ensureStateRoot();
            const cfg  = JSON.stringify(cfgRoot.config, null, 2)
                          .replace(/[<>&]/g, c=>({'<':'&lt;','>':'&gt;','&':'&amp;'})[c]);
            const name = 'GameAssist Config';
            let handout = findObjs({ type:'handout', name })[0];
            if (!handout) handout = createObj('handout', { name, archived:false });
            handout.set('notes', `<pre>Generated: ${ts} (${ver})\n\n${cfg}</pre>`);
            sendChat('GameAssist', `/w gm Config written to "${name}"`);
        }
        else if (sub === 'set' && parts.length >= 4) {
            const mod = parts[2];
            const [ key, ...rest ] = parts.slice(3).join(' ').split('=');
            const val = rest.join('=');
            const parsed = parseConfigValue(val);
            if (!MODULES[mod] || MODULES[mod].internal) {
                GameAssist.log('Config', `Unknown module: ${mod}`, 'WARN');
                return;
            }
            GameAssist.getState(mod).config[key.trim()] = parsed;
            GameAssist.log('Config', `Set ${mod}.${key.trim()} = ${JSON.stringify(parsed)}`);
        }
        else if (sub === 'get' && parts.length >= 4) {
            const mod = parts[2];
            const key = parts[3];
            if (!MODULES[mod] || MODULES[mod].internal) {
                GameAssist.log('Config', `Unknown module: ${mod}`, 'WARN');
                return;
            }
            const val = GameAssist.getState(mod).config[key];
            GameAssist.log('Config', `${mod}.${key} = ${JSON.stringify(val)}`);
        }
        else if (sub === 'ui') {
            if (typeof GameAssist.renderConfigUI !== 'function') {
                GameAssist.log('Config', 'Config UI module is disabled or unavailable.', 'WARN');
                return;
            }
            const raw = msg.content.trim().split(/\s+/).slice(2).join(' ');
            GameAssist.renderConfigUI(msg.playerid, { rawArgs: raw });
        }
        else if (sub === 'modules') {
            const moduleList = Object.entries(MODULES)
                .filter(([, mod]) => !mod.internal)
                .map(([name, mod]) => {
                    const cfg = GameAssist.getState(name).config;
                    const status = cfg.enabled ? '✅' : '❌';
                    const init = mod.initialized && mod.active ? '🟢' : '⏸️';
                    return `${status}${init} ${name}`;
                }).join('\n');
            GameAssist.log('Config', `Modules:\n${moduleList}`);
        }
        else {
            GameAssist.log('Config', 'Usage: !ga-config list|set|get|modules [args]');
        }
    }, 'Core', { gmOnly: true });

    // ————— CONTROL COMMANDS —————
    GameAssist.onCommand('!ga-enable', msg => {
        const mod = msg.content.split(/\s+/)[1];
        if (!mod) {
            GameAssist.log('Core', 'Usage: !ga-enable <module>', 'WARN');
            return;
        }
        GameAssist.enableModule(mod);
    }, 'Core', { gmOnly: true });

    GameAssist.onCommand('!ga-disable', msg => {
        const mod = msg.content.split(/\s+/)[1];
        if (!mod) {
            GameAssist.log('Core', 'Usage: !ga-disable <module>', 'WARN');
            return;
        }
        GameAssist.disableModule(mod);
    }, 'Core', { gmOnly: true });

    GameAssist.onCommand('!ga-status', msg => {
        const metrics = GameAssist._metrics;
        const avgDuration = metrics.taskDurations.length > 0
            ? (metrics.taskDurations.reduce((a,b) => a+b, 0) / metrics.taskDurations.length).toFixed(2)
            : 'N/A';

        const status = [
            `**GameAssist ${VERSION} Status**`,
            `Commands: ${metrics.commands}`,
            `Messages: ${metrics.messages}`,
            `Errors: ${metrics.errors}`,
            `Avg Task Duration: ${avgDuration}ms`,
            `Queue Length: ${_queue.length}`,
            `Last Update: ${metrics.lastUpdate || 'Never'}`,
            `Modules: ${Object.entries(MODULES).filter(([, m]) => !m.internal).length}`,
            `Active Listeners: ${Object.values(GameAssist._listeners).flat().length}`
        ].join('\n');

        GameAssist.log('Status', status);
    }, 'Core', { gmOnly: true });

    GameAssist.onCommand('!ga-metrics', msg => {
        const parts = msg.content.trim().split(/\s+/);
        const sub = (parts[1] || 'summary').toLowerCase();

        if (sub === 'reset') {
            resetMetricsStore();
            GameAssist._metrics.commands = 0;
            GameAssist._metrics.messages = 0;
            GameAssist._metrics.errors = 0;
            GameAssist._metrics.stateAudits = 0;
            GameAssist._metrics.taskDurations = [];
            GameAssist._metrics.lastUpdate = new Date().toISOString();
            recordMetric('system', { mod: 'Core', note: 'Metrics reset' });
            GameAssist.log('Metrics', 'Metrics reset. Session counters cleared.');
            return;
        }

        const store = getMetricsStore();
        const totals = store.totals || {};
        const durations = store.durations || [];
        const labels = {
            command: 'Commands',
            event: 'Events',
            task: 'Queue Tasks',
            toggle: 'Module Toggles',
            error: 'Errors',
            audit: 'State Audits',
            system: 'System Events'
        };

        const summary = [
            '**GameAssist Metrics**',
            `Session Start: ${store.sessionStart || 'unknown'}`,
            `Last Update: ${store.lastUpdate || 'unknown'}`
        ];

        Object.entries(labels).forEach(([key, label]) => {
            summary.push(`${label}: ${totals[key] || 0}`);
        });

        const extraKeys = Object.keys(totals).filter(key => !labels[key]).sort();
        extraKeys.forEach(key => {
            summary.push(`${key}: ${totals[key]}`);
        });

        if (durations.length) {
            const totalDur = durations.reduce((acc, val) => acc + val, 0);
            const avg = (totalDur / durations.length).toFixed(2);
            const min = Math.min(...durations);
            const max = Math.max(...durations);
            summary.push(`Queue Durations (last ${durations.length}): avg ${avg}ms | min ${min}ms | max ${max}ms`);
        } else {
            summary.push('Queue Durations: no tasks recorded yet.');
        }

        const history = (store.history || []).slice(-5).reverse();
        if (history.length) {
            summary.push('Recent activity:');
            history.forEach(entry => {
                const segments = [];
                if (entry.ts) segments.push(entry.ts);
                segments.push(entry.type);
                if (entry.mod) segments.push(`[${entry.mod}]`);
                if (entry.note) segments.push(`— ${entry.note}`);
                summary.push(`• ${segments.join(' ')}`.trim());
            });
        } else {
            summary.push('Recent activity: none logged.');
        }

        GameAssist.log('Metrics', summary.join('\n'));
    }, 'Core', { gmOnly: true });
    // --- Notes & Comments ---
    // CHOICE: Keep command syntax identical to legacy for drop‑in replacement.
    // [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS] END
    // =============================================================================

    // ————— CONFIG UI MODULE v0.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:CONFIGUI] BEGIN
    // Section Title: Config UI module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:CONFIGUI", title: "Config UI", 
    //   guarantees: ["GM chat menu for module toggles and quick config"], version: "0.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('ConfigUI', function() {
        const modState = GameAssist.getState('ConfigUI');
        Object.assign(modState.config, {
            enabled: true,
            pageSize: 3,
            showSummaries: true,
            ...modState.config
        });

        function getPageSize() {
            const raw = modState.config.pageSize;
            const parsed = Number(raw);
            return Number.isFinite(parsed) && parsed > 0 ? Math.floor(parsed) : 3;
        }

        function formatValue(value) {
            if (value === null || value === undefined) return '—';
            if (typeof value === 'object') {
                try { return JSON.stringify(value); }
                catch { return '[object]'; }
            }
            return String(value);
        }

        function formatConfigSummary(cfg) {
            const entries = Object.entries(cfg || {})
                .filter(([key]) => key !== 'enabled')
                .map(([key, val]) => `<span><strong>${_sanitize(key)}</strong>: ${_sanitize(formatValue(val))}</span>`);
            return entries.length ? entries.join(' • ') : '';
        }

        function buildConfigButtons(name, cfg) {
            return Object.entries(cfg || {})
                .filter(([key, val]) => key !== 'enabled' && typeof val === 'boolean')
                .map(([key, val]) => {
                    const label = `${key}: ${val ? 'ON' : 'OFF'}`;
                    const next  = (!val).toString();
                    return GameAssist.createButton(label, `!ga-config set ${name} ${key}=${next}`);
                })
                .join(' ');
        }

        function parsePage(rawArgs) {
            if (!rawArgs) return 0;
            const parsed = _parseArgs(rawArgs);
            const pageArg = parsed.args.page;
            if (typeof pageArg === 'number') return Math.max(0, pageArg);
            if (typeof pageArg === 'string') {
                const val = parseInt(pageArg, 10);
                if (!isNaN(val)) return Math.max(0, val);
            }
            if (parsed.cmd && /^\d+$/.test(parsed.cmd)) {
                return Math.max(0, parseInt(parsed.cmd, 10));
            }
            const direct = rawArgs.split(/\s+/).find(part => /^\d+$/.test(part));
            if (direct) return Math.max(0, parseInt(direct, 10));
            return 0;
        }

        function getModuleEntries() {
            return Object.entries(MODULES)
                .filter(([, mod]) => !mod.internal)
                .sort((a, b) => a[0].localeCompare(b[0], 'en', { sensitivity: 'base' }));
        }

        function buildNav(page, total) {
            if (total <= 1) return '';
            const buttons = [];
            if (page > 0) {
                buttons.push(GameAssist.createButton('⬅ Prev', `!ga-config ui --page ${page - 1}`));
            }
            buttons.push(GameAssist.createButton('🔄 Refresh', `!ga-config ui --page ${page}`));
            if (page < total - 1) {
                buttons.push(GameAssist.createButton('Next ➡', `!ga-config ui --page ${page + 1}`));
            }
            return buttons.join(' ');
        }

        function renderModuleBlock(name, mod) {
            const branch = GameAssist.getState(name);
            const cfg    = branch.config || {};
            const enabled = cfg.enabled !== false;
            const active  = !!(mod.initialized && mod.active);
            const statusIcon = enabled ? (active ? '🟢' : '⏸️') : '⛔';
            const statusText = enabled ? (active ? 'Enabled' : 'Disabled (inactive)') : 'Disabled';
            const toggleCmd  = enabled ? `!ga-disable ${name}` : `!ga-enable ${name}`;
            const toggleBtn  = GameAssist.createButton(`${enabled ? 'Disable' : 'Enable'} ${name}`, toggleCmd);
            const configButtons = buildConfigButtons(name, cfg);
            const summary = modState.config.showSummaries ? formatConfigSummary(cfg) : '';

            const rows = [
                `${statusIcon} <strong>${_sanitize(name)}</strong> — ${_sanitize(statusText)}`,
                toggleBtn
            ];
            if (configButtons) {
                rows.push(`Config: ${configButtons}`);
            }
            if (summary) {
                rows.push(summary);
            }
            return `<div style="margin-top:4px;">${rows.join('<br>')}</div>`;
        }

        function renderInternal(playerId, { page: explicitPage, rawArgs = '' } = {}) {
            const modules = getModuleEntries();
            if (!modules.length) {
                sendChat('GameAssist', '/w gm No modules registered.');
                return;
            }

            const pageSize = getPageSize();
            const totalPages = Math.max(1, Math.ceil(modules.length / pageSize));
            let page = typeof explicitPage === 'number' ? explicitPage : parsePage(rawArgs);
            if (!Number.isFinite(page) || page < 0) page = 0;
            if (page > totalPages - 1) page = totalPages - 1;

            const slice = modules.slice(page * pageSize, page * pageSize + pageSize);
            const blocks = slice.map(([name, mod]) => renderModuleBlock(name, mod)).join('');
            const nav = buildNav(page, totalPages);

            const header = `<div><strong>🛠️ GameAssist Config UI</strong> <span style="font-size:smaller;">Page ${page + 1}/${totalPages}</span></div>`;
            const footer = '<div style="margin-top:4px; font-size:smaller;">Use !ga-config set &lt;Module&gt; key=value for advanced settings.</div>';
            const navLine = nav ? `<div style="margin-top:4px;">${nav}</div>` : '';

            const message = `${header}${blocks}${navLine}${footer}`;
            sendChat('GameAssist', `/w gm ${message}`);
        }

        GameAssist.renderConfigUI = function(playerId, options = {}) {
            if (!MODULES.ConfigUI?.initialized || !MODULES.ConfigUI?.active) {
                GameAssist.log('ConfigUI', 'Config UI module is disabled.', 'WARN');
                return;
            }
            renderInternal(playerId, options);
        };

        GameAssist.onCommand('!ga-config-ui', msg => {
            const rawArgs = msg.content.replace(/^!ga-config-ui\s*/i, '');
            renderInternal(msg.playerid, { rawArgs });
        }, 'ConfigUI', { gmOnly: true });

        GameAssist.log('ConfigUI', 'Ready: !ga-config ui (or !ga-config-ui) to open chat controls.', 'INFO', { startup: true });
    }, {
        enabled: true,
        prefixes: ['!ga-config-ui', '!ga-config ui']
    });
    // --- Notes & Comments ---
    // CHOICE: Button helper reused; nav uses the same command path for refresh/paging.
    // [GAMEASSIST_GAMEASSIST:MODULES:CONFIGUI] END
    // =============================================================================

    // ————— CRITFUMBLE MODULE v0.2.4.9 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE] BEGIN
    // Section Title: CritFumble module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:CRITFUMBLE", title: "CritFumble",
    //   guarantees: ["Behavior unchanged; natural‑1 detection bugfix retained"], version: "0.2.4.9" }
    // -------------------------------------------------------------------------
    GameAssist.register('CritFumble', function() {
        // ─── Module Setup ──────────────────────────────────────────────────────────────
        const modState = GameAssist.getState('CritFumble');
        Object.assign(modState.config, {
            enabled:   true,
            debug:     true,
            useEmojis: true,
            rollDelayMs: 200,
            // Preserve any values previously saved in state
            ...modState.config
        });
        modState.runtime.activePlayers = modState.runtime.activePlayers || {};

        // ─── Constants ─────────────────────────────────────────────────────────────────
        /** Which Roll20 rolltemplates we watch for natural-1s */
        const VALID_TEMPLATES = ['atk','atkdmg','npcatk','spell'];
        const FUMBLE_TABLES = {
            melee:   'CF-Melee',
            ranged:  'CF-Ranged',
            spell:   'CF-Spell',
            natural: 'CF-Natural',
            thrown:  'CF-Thrown'
        };
        // Lookup for confirm tables
        const CONFIRM_TABLES = {
            'confirm-crit-martial': 'Confirm-Crit-Martial',
            'confirm-crit-magic':   'Confirm-Crit-Magic'
        };

        // ─── Helper Functions ──────────────────────────────────────────────────────────
        /**
         * debugLog(msg)
        *   Logs to the GM only when debug mode is on.
        *   Uses GameAssist.log under the hood.
        */
        function debugLog(msg) {
            if (modState.config.debug) {
                GameAssist.log('CritFumble', msg);
            }
        }
        function emoji(sym) {
            return modState.config.useEmojis ? sym : '';
        }

        // Strip off any " (GM)" suffix so /w target resolves
        function sanitizeWho(who) {
            return who.replace(/ \(GM\)$/, '');
        }

        function sendTemplateMessage(who,title,fields) {
            who = sanitizeWho(who);
            const content = fields.map(f=>`{{${f.label}=${f.value}}}`).join(' ');
            sendChat('CritFumble', `/w "${who}" &{template:default} {{name=${title}}} ${content}`);
        }

        function getFumbleTableName(type) {
            return FUMBLE_TABLES[type]||null;
        }

        function sendConfirmMenu(who) {
    const confirmButtons = [
        GameAssist.createButton('Confirm-Crit-Martial', '!Confirm-Crit-Martial'),
        GameAssist.createButton('Confirm-Crit-Magic', '!Confirm-Crit-Magic')
    ].join(' ');

    // Send to player
    sendTemplateMessage(who, `${emoji('❓')} Confirm Critical Miss`, [
        { label: "Choose Confirmation Type", value: confirmButtons }
    ]);
    // Also send to GM
    sendTemplateMessage('gm', `${emoji('❓')} Confirm Critical Miss for ${who}!`, [
        { label: "Choose Confirmation Type", value: confirmButtons }
    ]);
}

        function sendFumbleMenu(who) {
            sendConfirmMenu(who);
            const buttons = [
                GameAssist.createButton('⚔ Melee', '!critfumble-melee'),
                GameAssist.createButton('🏹 Ranged', '!critfumble-ranged'),
                GameAssist.createButton('🎯 Thrown', '!critfumble-thrown'),
                GameAssist.createButton('🔥 Spell', '!critfumble-spell'),
                GameAssist.createButton('👊 Natural/Unarmed', '!critfumble-natural')
            ].join(' ');
            sendTemplateMessage(who, `${emoji('💥')} Critical Miss!`, [
                { label: "What kind of attack was this?", value: buttons }
            ]);
            // also whisper to GM for awareness
            sendTemplateMessage('gm', `${emoji('💥')} Critical Miss for ${who}!`, [
                { label: "What kind of attack was this?", value: buttons }
            ]);
        }

        function announceTableRoll(tableName) {
            sendTemplateMessage('gm', `${emoji('🎲')} Rolling Table`, [
                { label: "Table", value: `**${tableName}**` }
            ]);
        }
        function executeTableRoll(tableName) {
            setTimeout(()=>{
                GameAssist.rollTable(tableName);
                debugLog(`Roll command executed: /roll 1t[${tableName}]`);
            }, modState.config.rollDelayMs);
        }

        function rollFumbleTable(who,type) {
            const table = getFumbleTableName(type);
            if (!table) {
                sendTemplateMessage(who, "⚠️ Invalid Fumble Type", [
                    { label: "Requested",    value: `"${type}"` },
                    { label: "Valid Types",  value: Object.keys(FUMBLE_TABLES).join(', ') }
                ]);
                debugLog(`Invalid fumble type "${type}"`);
                return;
            }
            announceTableRoll(table);
            executeTableRoll(table);
        }

        function rollConfirmTable(who,rawCommand) {
            const table = CONFIRM_TABLES[rawCommand.toLowerCase()];
            if (!table) {
                sendTemplateMessage(who, "⚠️ Invalid Confirm Type", [
                    { label: "Requested",     value: `"${rawCommand}"` },
                    { label: "Valid Options", value: Object.values(CONFIRM_TABLES).join(', ') }
                ]);
                debugLog(`Invalid confirm type "${rawCommand}"`);
                return;
            }
            announceTableRoll(table);
            executeTableRoll(table);
        }

        function hasNaturalOne(inlinerolls) {
    for (const group of inlinerolls) {
        if (!group || !group.results || !Array.isArray(group.results.rolls)) continue;
        for (const roll of group.results.rolls) {
            // Only look at d20 dice rolls
            if (roll.type !== 'R' || roll.sides !== 20 || !Array.isArray(roll.results)) continue;
            for (const result of roll.results) {
                // Defensive: result must have .v (value); .r is not always present
                if (typeof result.v !== 'number') continue;
                if (result.v === 1) return true;
            }
        }
    }
    return false;
}

        function showManualTriggerMenu() {
            const players = Object.values(modState.runtime.activePlayers);
            if (!players.length) {
                sendTemplateMessage('gm', "⚠️ No Players Detected", [
                    { label:"Note", value:"No players have been active yet this session." }
                ]);
                return;
            }
            const buttons = players.map(name =>
                GameAssist.createButton(name, `!critfumblemenu-${encodeURIComponent(name)}`)
            ).join(' ');
            sendTemplateMessage('gm',"Manually Trigger Fumble Menu",[
                { label:"Select Player", value:buttons }
            ]);
        }

        function handleManualTrigger(encodedName) {
            sendFumbleMenu(decodeURIComponent(encodedName));
            debugLog(`Manually triggered fumble menu for: ${encodedName}`);
        }

        function showHelpMessage(who) {
            sendTemplateMessage(who, "📘 CritFumble Help", [
                { label: "Version",     value: "v0.2.4.9" },
                { label: "Commands",    value: "`!critfail`, `!critfumble help`, `!critfumble-<type>`, `!confirm-crit-martial`, `!confirm-crit-magic`" },
                { label: "Description", value: "Auto-detects critical misses and prompts attacker with a fumble menu; GM can also manually trigger via `!critfail`." },
                { label: "Valid Types", value: Object.keys(FUMBLE_TABLES).join(', ') }
            ]);
        }

        function handleRoll(msg) {
            if (!msg) return;
            // register active players
            if (msg.playerid && !modState.runtime.activePlayers[msg.playerid]) {
                const p = getObj('player', msg.playerid);
                if (p) modState.runtime.activePlayers[msg.playerid] = p.get('displayname');
            }

            // API‐style commands
            if (msg.type==='api') {
                const cmd = (msg.content||'').trim().toLowerCase();

                if (cmd==='!critfail') {
                    debugLog('Manual trigger: !critfail');
                    return showManualTriggerMenu();
                }
                if (cmd==='!critfumble help') {
                    return showHelpMessage(msg.who);
                }
                if (cmd.startsWith('!critfumblemenu-')) {
                    return handleManualTrigger(msg.content.replace('!critfumblemenu-',''));
                }
                if (cmd.startsWith('!critfumble-')) {
                    const who        = sanitizeWho(msg.who);
                    const fumbleType = msg.content.replace('!critfumble-','').toLowerCase();
                    debugLog(`${who} selected fumble type: ${fumbleType}`);
                    return rollFumbleTable(who, fumbleType);
                }
                if (cmd.startsWith('!confirm-crit-')) {
                    const who        = sanitizeWho(msg.who);
                    const rawCommand = msg.content.slice(1);  // e.g. "confirm-crit-martial"
                    debugLog(`${who} selected confirm type: ${rawCommand}`);
                    return rollConfirmTable(who, rawCommand);
                }
                return;
            }

            // auto-detect natural 1 on a valid rolltemplate
            if (!msg.rolltemplate || !VALID_TEMPLATES.includes(msg.rolltemplate)) return;
            const rolls = msg.inlinerolls||[];
            if (!hasNaturalOne(rolls)) return;

            const who = sanitizeWho(msg.who);
            debugLog(`Fumble detected from: ${who}`);
            sendFumbleMenu(who);
        }

        GameAssist.onEvent('chat:message', handleRoll, 'CritFumble');
        GameAssist.log('CritFumble','v0.2.4.9 Ready: Auto fumble detection + !critfail','INFO',{startup:true});
    }, {
        enabled: true,
        events:   ['chat:message'],
        prefixes: ['!critfail','!critfumble']
    });
    // --- Notes & Comments ---
    // Bugfix retained: robust natural‑1 detection across templates/inlineroll variants.
    // [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE] END
    // =============================================================================

    // ————— NPC MANAGER MODULE v0.1.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER] BEGIN
    // Section Title: NPCManager module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:NPCMANAGER", title: "NPCManager",
    //   guarantees: ["Auto toggle dead marker based on HP"], version: "0.1.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('NPCManager', function() {
        const modState = GameAssist.getState('NPCManager');

        Object.assign(modState.config, {
            enabled: true,
            autoTrackDeath: true,
            deadMarker: 'dead',
            ...modState.config
        });

        function getNPCContext(token, link = null) {
            const linked = link || GameAssist.getLinkedCharacter(token);
            if (!linked) return null;

            const npcAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc'
            })[0];

            if (!npcAttr || npcAttr.get('current') !== '1') return null;
            return linked;
        }

        function checkForDeath(token) {
            if (!modState.config.autoTrackDeath) return;

            if (!getNPCContext(token)) return;

            const hp = parseInt(token.get('bar1_value'), 10) || 0;
            const markers = (token.get('statusmarkers') || '').split(',');
            const isDead = markers.includes(modState.config.deadMarker);

            if (hp < 1 && !isDead) {
                sendChat('api', `!token-mod --ids ${token.id} --set statusmarkers|+${modState.config.deadMarker}`);
                GameAssist.log('NPCManager', `${token.get('name')} marked as dead (HP: ${hp})`);
            } else if (hp >= 1 && isDead) {
                sendChat('api', `!token-mod --ids ${token.id} --set statusmarkers|-${modState.config.deadMarker}`);
                GameAssist.log('NPCManager', `${token.get('name')} revived (HP: ${hp})`);
            }
        }

        function handleTokenChange(obj, prev) {
            if (obj.get('bar1_value') !== prev.bar1_value) {
                checkForDeath(obj);
            }
        }

        GameAssist.onCommand('!npc-death-report', msg => {
            const pageId = Campaign().get('playerpageid');
            const tokens = findObjs({
                _pageid: pageId,
                _type: 'graphic',
                layer: 'objects'
            });

            const flagged = [];
            const invalid = [];
            for (let token of tokens) {
                const link = GameAssist.getLinkedCharacter(token);
                if (!link) {
                    invalid.push(token.get('name') || '(Unnamed)');
                    continue;
                }

                if (!getNPCContext(token, link)) continue;

                const hp = parseInt(token.get('bar1_value'), 10) || 0;
                const markers = (token.get('statusmarkers') || '').split(',');
                const isDead = markers.includes(modState.config.deadMarker);

                if ((hp < 1 && !isDead) || (hp >= 1 && isDead)) {
                    flagged.push({
                        name: token.get('name') || '(Unnamed)',
                        id: token.id,
                        hp,
                        markers: token.get('statusmarkers') || '(none)'
                    });
                }
            }

            if (flagged.length === 0) {
                GameAssist.log('NPCManager', '✅ Living NPCs have correct death marker states.');
            } else {
                GameAssist.log('NPCManager', `⚠️ ${flagged.length} NPC(s) with mismatched death markers:`);
                flagged.forEach(({ name, id, hp, markers }) => {
                    GameAssist.log('NPCManager', `- ${name} [${id}] | HP: ${hp} | Markers: ${markers}`);
                });
            }

            if (invalid.length) {
                GameAssist.log(
                    'NPCManager',
                    `Skipped ${invalid.length} token(s) with no linked character: ${invalid.join(', ')}`,
                    'WARN'
                );
            }
        }, 'NPCManager', { gmOnly: true });

        GameAssist.onEvent('change:graphic:bar1_value', handleTokenChange, 'NPCManager');
        GameAssist.log('NPCManager', 'v0.1.1.0 Ready: Auto death tracking + !npc-death-report', 'INFO', { startup: true });
    }, {
        enabled: true,
        events: ['change:graphic:bar1_value'],
        prefixes: ['!npc-death-report'],
        dependsOn: ['TokenMod'],
        teardown: () => {
            const branch = GameAssist.getState('NPCManager');
            const marker = branch?.config?.deadMarker || 'dead';
            const pageId = Campaign().get('playerpageid');

            if (!pageId) return;

            const targets = findObjs({
                _type: 'graphic',
                _pageid: pageId,
                layer: 'objects'
            }).filter(token => {
                const markers = (token.get('statusmarkers') || '').split(',');
                return markers.includes(marker);
            });

            if (!targets.length) return;

            targets.forEach(token => {
                sendChat('api', `!token-mod --ids ${token.id} --set statusmarkers|-${marker}`);
            });

            GameAssist.log('NPCManager', `Cleared ${targets.length} ${marker} marker(s) during teardown.`);
        }
    });
    // --- Notes & Comments ---
    // CHOICE: TokenMod used for status marker ops; keep dependency explicit in README.
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER] END
    // =============================================================================

// ————— CONCENTRATION TRACKER MODULE v0.1.0.5 —————
// =============================================================================
// [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER] BEGIN
// Section Title: ConcentrationTracker module
// -------------------------------------------------------------------------
// mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:CONCENTRATIONTRACKER", title: "ConcentrationTracker",
//   guarantees: ["Chat UI for concentration saves; TokenMod marker toggle"], version: "0.1.0.5" }
// -------------------------------------------------------------------------
GameAssist.register('ConcentrationTracker', function() {
    // ─── Module Setup ──────────────────────────────────────────────────────────────
    const modState = GameAssist.getState('ConcentrationTracker');
    Object.assign(modState.config, {
        enabled:   true,
        marker:    'Concentrating',
        randomize: true,
        ...modState.config
    });
    modState.runtime.lastDamage = modState.runtime.lastDamage || {};
    Object.entries(modState.runtime.lastDamage).forEach(([playerId, payload]) => {
        if (typeof payload === 'number' || typeof payload === 'string') {
            const dmg = Number(payload) || 0;
            modState.runtime.lastDamage[playerId] = {
                damage: dmg,
                dc: Math.max(10, Math.floor(dmg / 2)),
                mode: 'normal'
            };
        } else if (payload && typeof payload === 'object') {
            payload.damage = Number(payload.damage) || 0;
            if (payload.dc === undefined) {
                payload.dc = Math.max(10, Math.floor(payload.damage / 2));
            }
            if (!payload.mode) payload.mode = 'normal';
        }
    });

    // ─── Public Command Prefixes ───────────────────────────────────────────────────
    const CMDS = ['!concentration', '!cc'];
    const TOKEN_MARKER = 'Concentrating';

    // ─── Default Emote Lines ────────────────────────────────────────────────────────
    const DEFAULT_LINES = {
        success: [
            "steadies their breath, holding their focus.",
            "'s grip tightens as they maintain their spell.",
            "staggers slightly but does not lose concentration.",
            "clenches their jaw, magic still flickering with intent.",
            "narrows their eyes, spell still intact."
        ],
        failure: [
            "gasps, their focus shattered as the spell falters.",
            "'s concentration breaks and the magic fades.",
            "cries out, unable to maintain the spell.",
            "'s spell fizzles as they lose control.",
            "winces, focus lost in the heat of battle."
        ]
    };

    // ─── Helper Functions ──────────────────────────────────────────────────────────

    /**
     * getConfig()
     *   Merge default settings with stored config.
     */
    function getConfig() {
        return Object.assign({ randomize: true }, modState.config);
    }

    /**
     * getOutcomeLines(name)
     *   Returns the success/failure emote arrays with {{name}} replaced.
     */
    function getOutcomeLines(name) {
        const fill = line => line.replace("{{name}}", name);
        return {
            success: DEFAULT_LINES.success.map(fill),
            failure: DEFAULT_LINES.failure.map(fill)
        };
    }

    /**
     * getConBonus(character)
     *   Reads the character's Constitution saving throw bonus.
     */
    function getConBonus(character) {
        const attr = findObjs({
            _type:       'attribute',
            _characterid: character.id,
            name:        'constitution_save_bonus'
        })[0];
        return attr ? parseInt(attr.get('current'), 10) : 0;
    }

    /**
     * toggleMarker(token, on)
     *   Adds or removes the Concentrating status marker.
     */
    function toggleMarker(token, on) {
        sendChat('api',
            `!token-mod --ids ${token.id} --set statusmarkers|${on ? '+' : '-'}${TOKEN_MARKER}`
        );
    }

    /**
     * postButtons(recipient)
     *   Sends the three-button UI for a new concentration check.
     */
    function postButtons(recipient) {
        const dmg = '?{Damage taken?|0}';
        const buttons = [
            GameAssist.createButton('🎯 Maintain Control', `!concentration --damage ${dmg} --mode normal`),
            GameAssist.createButton('🧠 Brace for the Distraction', `!concentration --damage ${dmg} --mode adv`),
            GameAssist.createButton('😣 Struggling to Focus', `!concentration --damage ${dmg} --mode dis`)
        ].join(' ');
        sendChat('ConcentrationTracker',
            `/w "${recipient}" ${buttons}<br>⚠️ Select your token before clicking.`
        );
    }

    /**
     * sendResult(player, dc, total, rolls, formula)
     *   Whispers the concentration-check result to player & GM.
     */
    function sendResult(player, dc, total, rolls, formula) {
        const tpl =
            `&{template:default} {{name=🧠 Concentration Check}}` +
            ` {{DC=${dc}}} {{Result=Roll(s) ${rolls} → ${total} (from ${formula})}}`;
        sendChat('ConcentrationTracker', `/w "${player}" ${tpl}`);
        sendChat('ConcentrationTracker', `/w gm ${tpl}`);
    }

    /**
     * showStatus(player)
     *   Lists all tokens currently marked Concentrating.
     */
    function showStatus(player) {
        const page = Campaign().get('playerpageid');
        const tokens = findObjs({
            _type:  'graphic',
            _pageid: page,
            layer:  'objects'
        }).filter(t =>
            (t.get('statusmarkers') || '')
                .toLowerCase()
                .includes(TOKEN_MARKER.toLowerCase())
        );
        if (!tokens.length) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" No tokens concentrating.`
            );
        }
        let out = `&{template:default} {{name=🧠 Concentration Status}}`;
        tokens.forEach(t => {
            out += `{{${t.get('name') || 'Unnamed'}=Concentrating}}`;
        });
        sendChat('ConcentrationTracker', `/w "${player}" ${out}`);
    }

    function buildStatusTemplate() {
        const entries = Object.entries(modState.runtime.lastDamage || {});
        if (!entries.length) return null;

        const compiled = entries.map(([playerId, payload]) => {
            const data = (payload && typeof payload === 'object') ? payload : { damage: Number(payload) || 0 };
            const playerObj = getObj('player', playerId);
            const display = data.player || playerObj?.get('displayname') || 'Unknown Player';
            const playerName = display.replace(/ \(GM\)$/, '');
            const damage = Number(data.damage) || 0;
            const dc = data.dc ?? Math.max(10, Math.floor(damage / 2));
            const bonus = typeof data.bonus === 'number' ? data.bonus : null;
            const mode = data.mode || 'normal';
            const token = data.tokenId ? getObj('graphic', data.tokenId) : null;
            const character = data.characterId ? getObj('character', data.characterId) : null;
            const tokenName = data.tokenName || token?.get('name') || character?.get('name') || '(Token)';
            const characterName = data.characterName || character?.get('name') || tokenName;
            const recorded = data.timestamp ? new Date(data.timestamp).toLocaleTimeString() : '—';
            const bonusText = bonus !== null ? (bonus >= 0 ? `+${bonus}` : `${bonus}`) : '—';

            return {
                player: playerName,
                info: `${characterName} • DMG ${damage} → DC ${dc} • Bonus ${bonusText} • Mode ${mode} • @ ${recorded}`,
                timestamp: data.timestamp || 0
            };
        });

        compiled.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

        const rows = compiled.map(row => `{{${_sanitize(row.player)}=${_sanitize(row.info)}}}`);
        return `&{template:default} {{name=🧠 Concentration Status}} ${rows.join(' ')}`;
    }

    /**
     * showHelp(player)
     *   Whisper the full list of commands and usage.
     */
    function showHelp(player) {
        const helpText = [
            "🧠 Concentration Help:",
            "• !concentration / !cc → Show buttons",
            "• --damage X           → Roll vs DC = max(10,⌊X/2⌋)",
            "• --mode normal|adv|dis→ Set roll mode",
            "• --last               → Repeat last check",
            "• --off                → Remove marker from selected tokens",
            "• --status             → Who is concentrating",
            "• --config randomize on|off → Toggle emote randomization"
        ].join('<br>');
        sendChat('ConcentrationTracker', `/w "${player}" ${helpText}`);
    }

    /**
     * handleRoll(msg, damage, mode)
     *   Executes the concentration roll workflow.
     */
    function handleRoll(msg, damage, mode) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        if (!msg.selected?.length) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ No token selected.`
            );
        }
        const token = getObj('graphic', msg.selected[0]._id);
        if (!token) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ Token not found.`
            );
        }

        const linked = GameAssist.getLinkedCharacter(token);
        if (!linked) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ Token must be on the Objects layer and linked to a character.`
            );
        }

        const { character } = linked;

        const bonus = getConBonus(character);
        const dc    = Math.max(10, Math.floor(damage / 2));
        const name  = token.get('name') || character.get('name');
        const { success: S, failure: F } = getOutcomeLines(name);
        const { randomize } = getConfig();

        let expr = `1d20 + ${bonus}`;
        if (mode === 'adv') expr = `2d20kh1 + ${bonus}`;
        if (mode === 'dis') expr = `2d20kl1 + ${bonus}`;

        modState.runtime.lastDamage[msg.playerid] = {
            damage,
            dc,
            bonus,
            mode,
            tokenId: token.id,
            tokenName: name,
            characterId: character.id,
            characterName: character.get('name'),
            player,
            timestamp: Date.now()
        };

        sendChat('', `[[${expr}]]`, ops => {
            const roll = ops[0].inlinerolls?.[0];
            if (!roll) {
                return sendChat('ConcentrationTracker',
                    `/w "${player}" ⚠️ Roll failed.`
                );
            }
            const total   = roll.results.total;
            const formula = roll.expression;
            const vals    = roll.results.rolls[0].results.map(r => r.v);
            const rollsText = (mode === 'normal' ? vals[0] : vals.join(','));
            const ok        = total >= dc;

            sendResult(player, dc, total, rollsText, formula);

            const pool = ok ? S : F;
            const tail = randomize
                ? pool[Math.floor(Math.random() * pool.length)]
                : pool[0];
            sendChat(`character|${character.id}`, `/em ${tail}`);
            toggleMarker(token, ok);
        });
    }

    /**
     * handleClear(msg)
     *   Clears the marker from selected tokens.
     */
    function handleClear(msg) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        const skipped = [];

        msg.selected?.forEach(sel => {
            const t = getObj('graphic', sel._id);
            if (!t) {
                skipped.push('(Missing Token)');
                return;
            }

            if (!GameAssist.getLinkedCharacter(t)) {
                skipped.push(t.get('name') || '(Unnamed)');
                return;
            }

            toggleMarker(t, false);
        });

        let response = '✅ Cleared markers.';
        if (skipped.length) {
            response += ` Skipped: ${skipped.join(', ')}.`;
        }

        sendChat('ConcentrationTracker', `/w "${player}" ${response}`);
    }

    /**
     * handleLast(msg)
     *   Repeats the last concentration check.
     */
    function handleLast(msg) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        const entry  = modState.runtime.lastDamage[msg.playerid];
        const dmg    = typeof entry === 'object' ? Number(entry.damage) : Number(entry);
        if (!entry || !dmg) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ No previous damage.`
            );
        }
        const mode = typeof entry === 'object' && entry.mode ? entry.mode : 'normal';
        handleRoll(msg, dmg, mode);
    }

    // ─── Core Handler (Case-Insensitive) ──────────────────────────────────────────
    function handler(msg) {
        if (msg.type !== 'api') return;

        // 1) Normalize prefix: trim + lowercase
        const raw   = msg.content.trim();
        const parts = raw.toLowerCase().split(/\s+--/);
        const cmd   = parts.shift();             // "!concentration" or "!cc"
        if (!CMDS.includes(cmd)) return;

        // 2) Identify player (strip " (GM)")
        const player = msg.who.replace(/ \(GM\)$/, '');

        // 3) Config branch
        if (parts[0]?.startsWith('config ')) {
            const [, key, val] = parts[0].split(/\s+/);
            if (key === 'randomize') {
                modState.config.randomize = (val === 'on' || val === 'true');
                return sendChat('ConcentrationTracker',
                    `/w "${player}" ✅ Randomize = ${modState.config.randomize}`
                );
            }
            return sendChat('ConcentrationTracker',
                `/w "${player}" ❌ Unknown config ${key}`
            );
        }

        // 4) Parse flags
        let damage = 0, mode = 'normal';
        for (let p of parts) {
            if (p === 'help')   return showHelp(player);
            if (p === 'status') return showStatus(player);
            if (p === 'last')   return handleLast(msg);
            if (p === 'off')    return handleClear(msg);
            if (p.startsWith('damage ')) damage = parseInt(p.split(' ')[1], 10);
            if (p.startsWith('mode '))   mode   = p.split(' ')[1];
        }

        // 5) Execute
        if (damage > 0) {
            handleRoll(msg, damage, mode);
        } else {
            postButtons(player);
        }
    }

    // ─── Wire It Up ────────────────────────────────────────────────────────────────
    GameAssist.onCommand('!ga-conc-status', () => {
        const tpl = buildStatusTemplate();
        if (!tpl) {
            GameAssist.log('ConcentrationTracker', 'No concentration activity recorded yet.');
            return;
        }
        sendChat('ConcentrationTracker', `/w gm ${tpl}`);
    }, 'ConcentrationTracker', { gmOnly: true });

    GameAssist.onEvent('chat:message', handler, 'ConcentrationTracker');
    GameAssist.log(
        'ConcentrationTracker',
        `Ready: ${[...CMDS, '!ga-conc-status'].join(' & ')}`,
        'INFO',
        { startup: true }
    );
}, {
    enabled:  true,
    events: ['chat:message'],
    prefixes: ['!concentration','!cc','!ga-conc-status'],
    dependsOn: ['TokenMod'],
    teardown: () => {
        const page = Campaign().get('playerpageid');
        findObjs({ _type: 'graphic', _pageid: page, layer: 'objects' })
            .filter(t =>
                (t.get('statusmarkers') || '')
                    .toLowerCase()
                    .includes('concentrating')
            )
            .forEach(t =>
                sendChat('api',
                    `!token-mod --ids ${t.id} --set statusmarkers|-Concentrating`
                )
            );
    }
});
// --- Notes & Comments ---
// CHOICE: Keep lowercase parsing and aliases exactly as legacy; avoids user retraining.
// [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER] END
// =============================================================================

    // ————— NPC HP ROLLER MODULE v0.1.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER] BEGIN
    // Section Title: NPCHPRoller module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:NPCHPROLLER", title: "NPCHPRoller",
    //   guarantees: ["Parse NdM±K and set bar1 to rolled HP"], version: "0.1.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('NPCHPRoller', function() {
        const modState = GameAssist.getState('NPCHPRoller');

    Object.assign(modState.config, {
        enabled: true,
        autoRollOnAdd: false,
        ...modState.config
    });

        function parseDiceString(diceStr) {
            // Match “NdM”, “NdM+K”, “NdM + K”, “NdM-K”, case-insensitive on “d”
            const match = diceStr.match(
                /^\s*(\d+)\s*[dD]\s*(\d+)(?:\s*([+-])\s*(\d+))?\s*$/
            );
            if (!match) return null;

            const count = parseInt(match[1], 10);
            const sides = parseInt(match[2], 10);
            const sign  = match[3] === '-' ? -1 : 1;
            const bonus = match[4] ? sign * parseInt(match[4], 10) : 0;

            return { count, sides, bonus };
        }

        function rollDice(count, sides) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * sides) + 1;
            }
            return total;
        }

        function rollHP(diceData) {
            const { count, sides, bonus } = diceData;
            return rollDice(count, sides) + bonus;
        }

        function resolveNpcContext(token, { logWarnings = true } = {}) {
            if (!token) {
                if (logWarnings) {
                    GameAssist.log('NPCHPRoller', 'Token not found', 'WARN');
                }
                return null;
            }

            const linked = GameAssist.getLinkedCharacter(token);
            if (!linked) {
                if (logWarnings) {
                    GameAssist.log('NPCHPRoller', `${token.get('name') || 'Token'} must be linked to a character on the Objects layer.`, 'WARN');
                }
                return null;
            }

            const displayName = token.get('name') || linked.character.get('name') || 'Token';

            const npcAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc'
            })[0];

            if (!npcAttr || npcAttr.get('current') !== '1') {
                if (logWarnings) {
                    GameAssist.log('NPCHPRoller', `${displayName} is not flagged as an NPC.`, 'WARN');
                }
                return null;
            }

            const hpFormulaAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc_hpformula'
            })[0];

            if (!hpFormulaAttr) {
                if (logWarnings) {
                    GameAssist.log('NPCHPRoller', `No HP formula found for ${displayName}`, 'WARN');
                }
                return null;
            }

            const formula = hpFormulaAttr.get('current');
            const diceData = parseDiceString(formula);

            if (!diceData) {
                if (logWarnings) {
                    GameAssist.log('NPCHPRoller', `Invalid HP formula: ${formula}`, 'WARN');
                }
                return null;
            }

            return { linked, formula, diceData, displayName };
        }

        function rollTokenHP(token, { logWarnings = true, reason = 'manual' } = {}) {
            const context = resolveNpcContext(token, { logWarnings });
            if (!context) return false;

            const hp = rollHP(context.diceData);

            token.set('bar1_value', hp);
            token.set('bar1_max', hp);

            const suffix = reason === 'auto' ? ' (auto-roll on add)' : '';
            GameAssist.log('NPCHPRoller', `${context.displayName} HP set to ${hp} using [${context.formula}]${suffix}`);
            return true;
        }

        GameAssist.onCommand('!npc-hp-all', async msg => {
            const pageId = Campaign().get('playerpageid');
            const tokens = findObjs({
                _pageid: pageId,
                _type: 'graphic',
                layer: 'objects'
            });

            const npcTokens = [];
            const skipped = [];

            for (const token of tokens) {
                const link = GameAssist.getLinkedCharacter(token);
                if (!link) {
                    skipped.push(token.get('name') || '(Unnamed)');
                    continue;
                }

                const npcAttr = findObjs({
                    _type: 'attribute',
                    _characterid: link.character.id,
                    name: 'npc'
                })[0];

                if (npcAttr && npcAttr.get('current') === '1') {
                    npcTokens.push(token);
                }
            }

            GameAssist.log('NPCHPRoller', `Rolling HP for ${npcTokens.length} NPCs on current map...`);

            for (const token of npcTokens) {
                try {
                    rollTokenHP(token);
                } catch (err) {
                    GameAssist.log('NPCHPRoller', `Error processing ${token.get('name')}: ${err.message}`, 'ERROR');
                }
            }

            if (skipped.length) {
                GameAssist.log('NPCHPRoller', `Skipped ${skipped.length} token(s) without linked characters: ${skipped.join(', ')}`, 'WARN');
            }
        }, 'NPCHPRoller', { gmOnly: true });

        GameAssist.onCommand('!npc-hp-selected', msg => {
            if (!msg.selected || msg.selected.length === 0) {
                GameAssist.log('NPCHPRoller', 'No tokens selected', 'WARN');
                return;
            }

            const skipped = [];

            msg.selected.forEach(sel => {
                const token = getObj('graphic', sel._id);
                if (!token) {
                    skipped.push('(Missing Token)');
                    return;
                }

                if (!GameAssist.getLinkedCharacter(token)) {
                    skipped.push(token.get('name') || '(Unnamed)');
                    return;
                }

                try {
                    rollTokenHP(token);
                } catch (err) {
                    GameAssist.log('NPCHPRoller', `Error processing ${token.get('name')}: ${err.message}`, 'ERROR');
                }
            });

            if (skipped.length) {
                GameAssist.log('NPCHPRoller', `Skipped ${skipped.length} token(s): ${skipped.join(', ')}`, 'WARN');
            }
        }, 'NPCHPRoller', { gmOnly: true });

        GameAssist.onEvent('add:graphic', token => {
            if (!modState.config.autoRollOnAdd) return;
            rollTokenHP(token, { logWarnings: false, reason: 'auto' });
        }, 'NPCHPRoller');

    GameAssist.log('NPCHPRoller', 'v0.1.1.0 Ready: !npc-hp-all, !npc-hp-selected', 'INFO', { startup: true });
}, {
    enabled: true,
    events: ['add:graphic'],
    prefixes: ['!npc-hp-all', '!npc-hp-selected']
});
// --- Notes & Comments ---
// CHOICE: Use Math.random for simplicity; acceptable for non‑critical HP rolls.
// [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER] END
// =============================================================================

    // ————— DEBUG TOOLS MODULE v0.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:DEBUGTOOLS] BEGIN
    // Section Title: DebugTools module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:DEBUGTOOLS", title: "DebugTools",
    //   guarantees: ["Dry-run friendly debugging helpers"], version: "0.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('DebugTools', function() {
        const modState = GameAssist.getState('DebugTools');
        Object.assign(modState.config, {
            enabled: false,
            ...modState.config
        });
        modState.runtime = modState.runtime || {};

        function wantsApply(args) {
            if (args.apply === undefined) return false;
            if (args.apply === false) return false;
            if (typeof args.apply === 'string') {
                return args.apply.toLowerCase() !== 'false';
            }
            return Boolean(args.apply);
        }

        function getTokenFromArgs(msg, args) {
            let tokenId = null;
            if (typeof args.token === 'string') tokenId = args.token;
            else if (Array.isArray(args.token) && args.token.length) tokenId = args.token[0];

            if (!tokenId && msg.selected?.length) {
                tokenId = msg.selected[0]._id;
            }

            if (!tokenId) return null;

            const token = getObj('graphic', tokenId);
            if (!token) {
                GameAssist.log('DebugTools', `Token ${tokenId} not found.`, 'WARN');
                return null;
            }
            if (token.get('layer') !== 'objects') {
                GameAssist.log('DebugTools', 'Token must be on the Objects layer.', 'WARN');
                return null;
            }
            return token;
        }

        function handleDamage(msg, args) {
            const token = getTokenFromArgs(msg, args);
            if (!token) {
                GameAssist.log('DebugTools', 'Select a token or pass --token <id> for damage tests.', 'WARN');
                return;
            }

            const amountRaw = args.amount ?? args.damage ?? args.value;
            const amount = Number(amountRaw);
            if (!Number.isFinite(amount) || amount <= 0) {
                GameAssist.log('DebugTools', 'Provide --amount <number> greater than zero.', 'WARN');
                return;
            }

            const current = Number(token.get('bar1_value')) || 0;
            const next    = Math.max(0, current - amount);
            const name    = _sanitize(token.get('name') || token.id);
            const summary = `${name}: HP ${current} → ${next} (-${amount})`;

            if (!wantsApply(args)) {
                GameAssist.log('DebugTools', `Dry run — would apply ${summary}. Add --apply to commit.`);
                return;
            }

            token.set('bar1_value', next);
            GameAssist.log('DebugTools', `Applied ${summary}.`);
            modState.runtime.lastAction = { type: 'damage', token: token.id, amount, previous: current };
        }

        function handleMarker(msg, args) {
            const token = getTokenFromArgs(msg, args);
            if (!token) {
                GameAssist.log('DebugTools', 'Select a token or pass --token <id> for marker tests.', 'WARN');
                return;
            }

            const markerRaw = args.marker ?? args.status;
            const marker = (markerRaw ? String(markerRaw) : 'blue').trim();
            if (!marker) {
                GameAssist.log('DebugTools', 'Provide --marker <status name>.', 'WARN');
                return;
            }

            const modeRaw = args.state ?? args.mode ?? args.action;
            const mode = modeRaw ? String(modeRaw).toLowerCase() : 'toggle';
            const markers = (token.get('statusmarkers') || '').split(',').filter(Boolean);
            const hasMarker = markers.includes(marker);
            let finalMarkers = markers.slice();
            let actionDesc;

            if (mode === 'on' || mode === 'add') {
                if (!hasMarker) finalMarkers.push(marker);
                actionDesc = `add ${marker}`;
            } else if (mode === 'off' || mode === 'remove' || mode === 'clear') {
                finalMarkers = markers.filter(m => m !== marker);
                actionDesc = `remove ${marker}`;
            } else {
                if (hasMarker) finalMarkers = markers.filter(m => m !== marker);
                else finalMarkers.push(marker);
                actionDesc = `${hasMarker ? 'remove' : 'add'} ${marker}`;
            }

            const name = _sanitize(token.get('name') || token.id);
            if (!wantsApply(args)) {
                GameAssist.log('DebugTools', `Dry run — would ${actionDesc} on ${name}. Add --apply to commit.`);
                return;
            }

            token.set('statusmarkers', finalMarkers.join(','));
            GameAssist.log('DebugTools', `Marker action: ${actionDesc} on ${name}.`);
            modState.runtime.lastAction = { type: 'marker', token: token.id, marker, mode };
        }

        function handleSave(msg, args) {
            const dcRaw = args.dc ?? args.target;
            const dc = Number(dcRaw);
            if (!Number.isFinite(dc)) {
                GameAssist.log('DebugTools', 'Provide --dc <number> for save tests.', 'WARN');
                return;
            }

            const bonusRaw = args.bonus ?? args.mod ?? 0;
            const bonus = Number(bonusRaw) || 0;
            const modeRaw = args.mode ?? args.roll ?? '';
            const mode = typeof modeRaw === 'string' ? modeRaw.toLowerCase() : '';
            let expr = `1d20 + ${bonus}`;
            let descriptor = 'normal';
            if (mode.startsWith('adv')) {
                expr = `2d20kh1 + ${bonus}`;
                descriptor = 'advantage';
            } else if (mode.startsWith('dis')) {
                expr = `2d20kl1 + ${bonus}`;
                descriptor = 'disadvantage';
            }

            if (!wantsApply(args)) {
                GameAssist.log('DebugTools', `Dry run — would roll ${expr} vs DC ${dc} (${descriptor}). Add --apply to execute.`);
                return;
            }

            const label = args.label ? _sanitize(String(args.label)) : 'Debug Save';
            sendChat('', `[[${expr}]]`, ops => {
                const roll = ops?.[0]?.inlinerolls?.[0];
                if (!roll) {
                    GameAssist.log('DebugTools', 'Save roll failed.', 'WARN');
                    return;
                }
                const total = roll.results.total;
                const success = total >= dc;
                const outcome = success ? '✅ Success' : '❌ Failure';
                const template = `&{template:default} {{name=${label}}} {{Result=${total} vs DC ${dc}}} {{Outcome=${outcome} (${descriptor})}}`;
                sendChat('DebugTools', `/w gm ${template}`);
                GameAssist.log('DebugTools', `Rolled ${total} vs DC ${dc} (${descriptor}). ${success ? 'Success' : 'Failure'}.`);
            });
        }

        function showHelp() {
            GameAssist.log('DebugTools', [
                'Debug helpers:',
                '• !ga-debug damage --amount N [--token TOKENID|select] [--apply]',
                '• !ga-debug marker --marker status [--state on|off|toggle] [--token TOKENID|select] [--apply]',
                '• !ga-debug save --dc N [--bonus M] [--mode normal|adv|dis] [--label Text] [--apply]'
            ].join('\n'));
        }

        const HANDLERS = {
            damage: handleDamage,
            marker: handleMarker,
            save: handleSave
        };

        GameAssist.onCommand('!ga-debug', msg => {
            const payload = msg.content.replace(/^!ga-debug\s*/i, '');
            if (!payload) {
                showHelp();
                return;
            }

            const parsed = _parseArgs(payload);
            const action = (parsed.cmd || '').toLowerCase();
            const handler = HANDLERS[action];
            if (!handler) {
                GameAssist.log('DebugTools', `Unknown debug action: ${_sanitize(action || '(none)')}`, 'WARN');
                showHelp();
                return;
            }
            handler(msg, parsed.args || {});
        }, 'DebugTools', { gmOnly: true });

        GameAssist.log('DebugTools', 'Debug module registered. Enable with !ga-enable DebugTools when needed.', 'INFO', { startup: true });
    }, {
        enabled: false,
        prefixes: ['!ga-debug']
    });
    // --- Notes & Comments ---
    // CHOICE: Helpers default to dry-run; --apply required for mutations.
    // [GAMEASSIST_GAMEASSIST:MODULES:DEBUGTOOLS] END
    // =============================================================================

    // ————— BOOTSTRAP —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:BOOTSTRAP] BEGIN
    // Section Title: Sandbox ready bootstrap
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "BOOTSTRAP", title: "Bootstrap",
    //   guarantees: ["Seed defaults, audit state, init enabled modules"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    on('ready', () => {
        if (READY) return;
        READY = true;

        const root = ensureStateRoot();
        GameAssist.config = root.config;
        if (!root.metrics.sessionStart) {
            root.metrics.sessionStart = new Date().toISOString();
        }
        recordMetric('system', { mod: 'Core', note: 'Sandbox ready' });

        GameAssist._clearAllListeners();
        seedDefaults();
        auditState();
        GameAssist._dedupePlanned();
        auditCompatibility();

        const moduleNames = Object.entries(MODULES)
            .filter(([, mod]) => !mod.internal)
            .map(([name]) => name);

        GameAssist.log('Core', `GameAssist v${VERSION} ready; modules: ${moduleNames.join(', ')}`);

        moduleNames.forEach(name => {
            const mod = MODULES[name];
            const cfg = getState(name).config;

            const depInfo = GameAssist._checkDependencies(name);
            if (depInfo.missing.length) {
                GameAssist.log('Core', `${name} skipped (missing dependencies: ${depInfo.missing.join(', ')})`, 'WARN');
                cfg.enabled = false;
                mod.initialized = false;
                mod.active = false;
                return;
            }
            if (!depInfo.verified && (mod.dependsOn || []).length) {
                GameAssist.log('Core', `${name} dependency scan limited (state.api.scripts unavailable); proceeding without verification.`, 'WARN');
            }

            if (cfg.enabled) {
                try {
                    if (!mod.wired) {
                        mod.initFn();
                        mod.wired = true;
                    }
                    mod.initialized = true;
                    mod.active = true;
                } catch (e) {
                    mod.initialized = false;
                    mod.active = false;
                    GameAssist.handleError(name, e);
                }
            } else {
                mod.initialized = false;
                mod.active = false;
            }
        });

        GameAssist._metrics.lastUpdate = new Date().toISOString();
    });
    // --- Notes & Comments ---
    // CHOICE: Core ready log is never suppressed; mirrors README guidance.
    // [GAMEASSIST_GAMEASSIST:BOOTSTRAP] END
    // =============================================================================

})();

// --- Notes & Comments ---
// Parent wrapper: No behavior changes. This mechsuit only adds structure and documentation.
// Prior notes (selected):
//   • MIT license retained; copyright © 2025 Mord Eagle.
//   • Modules: ConfigUI, CritFumble, NPCManager, ConcentrationTracker, NPCHPRoller, DebugTools.
//   • Queue/watchdog defaults preserved (30s/15s).
//   • Logging emits /w gm with icons and timestamp.
// [GAMEASSIST_GAMEASSIST:APP] END
// ============================================================================
