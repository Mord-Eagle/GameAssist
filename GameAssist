/* 
========================================
GameAssist — Roll20 API Script
Version: 0.1.1.2
Last Updated: 2025-09-16 (America/Detroit)
Author: Mord Eagle
License: MIT (see repository LICENSE)
Homepage: https://github.com/Roll20/roll20-api-scripts (submission target)

DESCRIPTION
GameAssist is a small framework for organizing Roll20 API modules with a safe task queue,
watchdog, config/state helpers, and consistent logging. This package ships with four modules:
• CritFumble — Detects natural-1s on selected rolltemplates and offers fumble/confirm menus.
• ConcentrationTracker — Runs concentration checks (normal/adv/dis), whispers results, toggles marker.
• NPCManager — Tracks NPC death markers based on bar1 HP.
• NPCHPRoller — Rolls NPC HP from `npc_hpformula` and writes to bar1 (value/max).

INSTALL / USAGE (One-Click or Manual)
• One-Click: install “GameAssist”. (Make sure “TokenMod” is also installed; see Dependencies.)
• Manual (Pro): paste this entire file into the API Scripts editor and Save.

CORE COMMANDS (GM):
• !ga-config list                          — write config handout “GameAssist Config”
• !ga-config modules                       — list modules + status
• !ga-config set <Module> key=value        — set module config (JSON/number/bool supported)
• !ga-config get <Module> key              — echo module config value
• !ga-enable <Module> / !ga-disable <Module>
• !ga-status                               — show metrics + listeners

MODULE COMMANDS:
• CritFumble:
    !critfail                               — GM menu to trigger fumble UI for a player
    !critfumble help                        — help
    !critfumble-<melee|ranged|thrown|spell|natural>
    !confirm-crit-martial   | !confirm-crit-magic
• ConcentrationTracker (players/GM):
    !concentration [--damage N] [--mode normal|adv|dis] [--off|--status|--last|--config randomize on|off]
    !cc (alias)
• NPCManager (GM):         !npc-death-report
• NPCHPRoller (GM):        !npc-hp-selected    |   !npc-hp-all

DEPENDENCIES
• TokenMod — required for marker/status changes issued by NPCManager and ConcentrationTracker.

CONFIGURATION NOTES
• Global flags (in code): GameAssist.flags.DEBUG_COMPAT, GameAssist.flags.QUIET_STARTUP.
• Per-module config via !ga-config set; types: boolean, number, JSON object/array, string.

COMPATIBILITY / FOOTPRINT
• Namespaced under global `GameAssist`. Avoids polluting global scope otherwise.
• Uses standard events: `on('ready')`, `on('chat:message')`, and graphic change events.
• Writes only to Roll20 objects documented in script.json: handout notes, token bars/markers.

SUPPORT / HELP
• Use !ga-status for quick health; !ga-config list creates a “GameAssist Config” handout.
• For bug reports, include the console whisper output from `GameAssist.log(...)`.

HEADER REQUIREMENTS NOTE
Per the Roll20 API repo contribution guidelines, this header provides name, version, last updated,
description, syntax/commands, and configuration pointers near the top of the script. 
========================================
*/

// --- MECHSUITS BANNER (YAML) ---
// mechsuit:
//   codename: "GAMEASSIST_GAMEASSIST"
//   purpose: "Roll20 API modular kernel and bundled modules (CritFumble, NPCManager, ConcentrationTracker, NPCHPRoller). This file adds MECHSUITS framing (sections, policy, notes) without changing runtime behavior. Non-goals: sheet-specific integrations or transport changes beyond Roll20 chat API."
//   order: ["app","policy","imports","utils","core.queue","core.state","compat","core.object","interfaces.commands","interfaces.events","modules","bootstrap"]
//   env:
//     required: []
//     optional: []
//     secrets: []
//   data_class: "Internal"
//   ai_data: "internal_redacted"
//   observability:
//     logs: "roll20_whisper_to_gm"
//     metrics: [{ name: "gameassist.queue.task_duration_ms", unit: "ms" }]
//     spans: ["[GAMEASSIST_GAMEASSIST:CORE:QUEUE]","[GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE]"]
//   performance: { throughput_ops: 1, latency_p99_ms: 1000 }
//   concurrency: { model: "Serialized task queue", idempotency: "N/A (event-driven)" }
//   compatibility: { accepts: ["Roll20 API sandbox (2025-04-09 build or later)"], emits: "Roll20 chat whispers/logs" }
//   policy: { notes_ref: "[GAMEASSIST_GAMEASSIST:POLICY]" }
//   error_codes: ["INVALID_ARGUMENT","NOT_FOUND","CONFLICT","UNAUTHORIZED","FORBIDDEN","UNPROCESSABLE","RATE_LIMITED","TIMEOUT","UNAVAILABLE","INTERNAL"]
//   transport_map:
//     chat: "Errors are whispered to GM; status/info are whispered as structured text"
//   canonical_tree: |
//     [GAMEASSIST_GAMEASSIST]/
//     ├─ [GAMEASSIST_GAMEASSIST:APP]
//     │  ├─ [GAMEASSIST_GAMEASSIST:POLICY]
//     │  ├─ [GAMEASSIST_GAMEASSIST:APP:IMPORTS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:APP:UTILS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:QUEUE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:STATE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:COMPAT]
//     │  ├─ [GAMEASSIST_GAMEASSIST:CORE:OBJECT]
//     │  ├─ [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER]
//     │  ├─ [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER]
//     │  └─ [GAMEASSIST_GAMEASSIST:BOOTSTRAP]
// --- prose banner ---
// Guarantee: This is a structural wrap of GameAssist v0.1.2 for Roll20 — it reorganizes the file into MECHSUITS sections with notes and policy while preserving all code and behavior.
// Secrets: none. Logs whisper to GM. Refusal: this file does not alter module logic, transport semantics, or sheet-specific behavior; those are out of scope here.

// =============================
// === GameAssist v0.1.2 ===
// === Author: Mord Eagle ===
// =============================
// Released under the MIT License (see https://opensource.org/licenses/MIT)
//
// Copyright (c) 2025 Mord Eagle
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// =============================================================================
// [GAMEASSIST_GAMEASSIST:APP] BEGIN
// Section Title: GameAssist — Roll20 API micro‑kernel with modules (wrapper)
// -----------------------------------------------------------------------------
// mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "APP", title: "Wrapper",
//   guarantees: ["Framed sections only; original behavior intact"],
//   depends_on: [], version: "1.0.0" }
// -----------------------------------------------------------------------------

(() => {
    'use strict';

    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:POLICY] BEGIN
    // Section Title: Tunables & flags (non‑behavioral framing)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "POLICY", title: "Tunables",
    //   guarantees: ["Documented timeouts; do not change values here from legacy"],
    //   version: "1.0.0" }
    // -------------------------------------------------------------------------
    // NOTE: We declare canonical names mirroring legacy constants; values remain identical.
    //       Changing these would alter behavior; out of scope for this structural wrap.
    // --- Notes & Comments ---
    // CHOICE: Keep constants inline with legacy names to avoid breaking changes.
    // ALT: Refactor to POLICY object and import; REJECTED for now (no behavior change rule).
    // [GAMEASSIST_GAMEASSIST:POLICY] END
    // =============================================================================

    const VERSION      = '0.1.1.2';
    const STATE_KEY    = 'GameAssist';
    const MODULES      = {};
    const _transitioning   = {};
    let   READY        = false;

    MODULES.Core = {
        internal:    true,
        initFn:      () => {},
        teardown:    null,
        enabled:     true,
        initialized: true,
        active:      true,
        events:      [],
        prefixes:    [],
        wired:       true,
        dependsOn:   []
    };

    // ————— QUEUE + WATCHDOG —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:QUEUE] BEGIN
    // Section Title: Serialized task queue + watchdog
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:QUEUE", title: "Queue",
    //   guarantees: ["Single in‑flight task; watchdog resets hung jobs"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    let _busy      = false;
    let _lastStart = 0;
    const _queue            = [];
    const DEFAULT_TIMEOUT   = 30000;
    const WATCHDOG_INTERVAL = 15000;

    function _enqueue(task, priority = 0, timeout = DEFAULT_TIMEOUT) {
        _queue.push({ task, priority, enqueuedAt: Date.now(), timeout });
        _queue.sort((a,b) => b.priority - a.priority || a.enqueuedAt - b.enqueuedAt);
        _runNext();
    }

    function _runNext() {
        if (_busy || !_queue.length) return;
        const { task, timeout } = _queue.shift();
        _busy = true;
        _lastStart = Date.now();

        const timer = setTimeout(() => {
            GameAssist.log('Core', `Task timed out after ${timeout}ms`, 'WARN');
            _busy = false;
            _runNext();
        }, timeout);

        Promise.resolve()
            .then(task)
            .catch(err => GameAssist.log('Core', `Error in task: ${err.message}`, 'ERROR'))
            .finally(() => {
                clearTimeout(timer);
                _busy = false;
                const duration = Date.now() - _lastStart;
                GameAssist._metrics.taskDurations.push(duration);
                GameAssist._metrics.lastUpdate = new Date().toISOString();
                _runNext();
            });
    }

    setInterval(() => {
        if (_busy && Date.now() - _lastStart > DEFAULT_TIMEOUT * 2) {
            GameAssist.log('Core', 'Watchdog forced queue reset', 'WARN');
            _busy = false;
            _runNext();
        }
    }, WATCHDOG_INTERVAL);
    // --- Notes & Comments ---
    // Decision log:
    //   CHOICE: FIFO with priority bump via sort; simple and sufficient for sandbox.
    //   CHOICE: Watchdog at 2× DEFAULT_TIMEOUT; mirrors legacy behavior.
    // [GAMEASSIST_GAMEASSIST:CORE:QUEUE] END
    // =============================================================================

    // ————— HANDLER TRACKING —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS] BEGIN
    // Section Title: Roll20 on/off wrappers and handler registry
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "INTERFACES:EVENTS", title: "Handlers",
    //   guarantees: ["Track listeners for safe enable/disable"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    globalThis._handlers = globalThis._handlers || {};
    const originalOn  = typeof globalThis.on  === 'function' ? globalThis.on  : null;
    const originalOff = typeof globalThis.off === 'function' ? globalThis.off : null;

    globalThis.on = (event, handler) => {
        globalThis._handlers[event] = globalThis._handlers[event] || [];
        globalThis._handlers[event].push(handler);
        if (typeof originalOn === 'function') {
            return originalOn(event, handler);
        }
    };

    globalThis.off = (event, handler) => {
        if (!globalThis._handlers[event]) return;
        globalThis._handlers[event] = globalThis._handlers[event].filter(h => h !== handler);
        if (typeof originalOff === 'function') {
            return originalOff(event, handler);
        }
    };
    // --- Notes & Comments ---
    // CHOICE: Wrap global on/off to keep a registry for teardown; avoids leaks.
    // [GAMEASSIST_GAMEASSIST:INTERFACES:EVENTS] END
    // =============================================================================

    // ————— UTILITIES —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:APP:UTILS] BEGIN
    // Section Title: Utilities (arg parsing, state helpers, audit, sanitize)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "APP:UTILS", title: "Utilities",
    //   guarantees: ["Pure helpers; no external side‑effects"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    function _parseArgs(content) {
        const args = {}, pattern = /--(\w+)(?:\s+("[^"]*"|[^\s]+))?/g;
        let m;
        while ((m = pattern.exec(content))) {
            let v = m[2] || true;
            if (typeof v === 'string') {
                if (/^".*"$/.test(v))      v = v.slice(1, -1);
                else if (/^\d+$/.test(v))  v = parseInt(v, 10);
                else if (/,/.test(v))      v = v.split(',');
            }
            args[m[1]] = v;
        }
        return { cmd: content.split(/\s+/)[0], args };
    }

    function getState(mod) {
        state[STATE_KEY] = state[STATE_KEY] || { config: {} };
        state[STATE_KEY][mod] = state[STATE_KEY][mod] || { config: {}, runtime: {} };
        return state[STATE_KEY][mod];
    }
    function saveState(mod, data) {
        state[STATE_KEY] = state[STATE_KEY] || { config: {} };
        state[STATE_KEY][mod] = Object.assign(getState(mod), data);
    }
    function clearState(mod) {
        if (state[STATE_KEY]?.[mod]) delete state[STATE_KEY][mod];
    }

    function auditState() {
        const root = state[STATE_KEY] || {};
        const whitelist = new Set(['config', 'flags', 'metrics']);

        Object.keys(root).forEach(k => {
            if (whitelist.has(k)) return;

            const mod = MODULES[k];
            if (!mod || mod.internal) {
                GameAssist.log('Core', `Unexpected state branch: ${k}`, 'WARN');
                return;
            }

            const branch = root[k];
            if (!branch?.config || !branch?.runtime) {
                GameAssist.log('Core', `Malformed state for ${k}`, 'WARN');
            }
        });
        GameAssist._metrics.stateAudits++;
        GameAssist._metrics.lastUpdate = new Date().toISOString();
    }

    function seedDefaults() {
        Object.entries(MODULES).forEach(([name, mod]) => {
            if (mod.internal) return;
            const cfg = getState(name).config;
            if (cfg.enabled === undefined) cfg.enabled = mod.enabled;
        });
    }

    function _sanitize(str = '') {
        return str.toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&#39;')
            .replace(/"/g, '&quot;');
    }

    function getLinkedCharacter(token) {
        if (!token || typeof token.get !== 'function') return null;
        if (token.get('layer') !== 'objects') return null;

        const charId = token.get('represents');
        if (!charId) return null;

        const character = getObj('character', charId);
        if (!character) return null;

        return { token, character };
    }
    // --- Notes & Comments ---
    // NOTE: State auditor warns about unexpected branches; no automatic deletion occurs.
    // [GAMEASSIST_GAMEASSIST:APP:UTILS] END
    // =============================================================================

    // ————— COMPATIBILITY —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:COMPAT] BEGIN
    // Section Title: Compatibility audit
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:COMPAT", title: "Compat",
    //   guarantees: ["Optional visibility of known/unknown scripts"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    const KNOWN_SCRIPTS = [
        'tokenmod.js','universaltvttimporter.js','npc-hp.js','wolfpack.js',
        'critfumble.js','rana-curse.js','statusinfo.js','npc death tracker.js',
        'customizable roll listener.js','5th edition ogl by roll20 companion.js'
    ];
    function normalizeScriptName(n) {
        return (n||'')
            .toLowerCase()
            .replace(/\.js$/, '')
            .replace(/[\s_]+/g, '-')
            .replace(/[^\w-]/g, '');
    }
    function auditCompatibility() {
        if (!GameAssist.flags.DEBUG_COMPAT) return;
        const known  = KNOWN_SCRIPTS.map(normalizeScriptName);
        const active = Object.keys(state.api?.scripts || {}).map(normalizeScriptName);
        const good   = active.filter(n => known.includes(n));
        const bad    = active.filter(n => !known.includes(n));
        GameAssist.log('Compat', '✅ Known: '  + (good.join(', ')  || 'none'));
        GameAssist.log('Compat', '❓ Unknown: ' + (bad.join(', ')   || 'none'));
        GameAssist.log('Compat', '🔌 Events: '   + GameAssist._plannedEvents.join(', '));
        GameAssist.log('Compat', '💬 Commands: ' + GameAssist._plannedChatPrefixes.join(', '));
    }
    // --- Notes & Comments ---
    // CHOICE: DEBUG_COMPAT gate avoids noise; GM toggles as needed.
    // [GAMEASSIST_GAMEASSIST:CORE:COMPAT] END
    // =============================================================================

    // ————— CONFIG PARSER —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:STATE] BEGIN
    // Section Title: Config parser (aux to state management)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:STATE", title: "Config parser",
    //   guarantees: ["Parse JSON/boolean/number safely"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    function parseConfigValue(raw) {
        raw = raw.trim();
        if (raw === 'true')  return true;
        if (raw === 'false') return false;
        if (!isNaN(raw))      return Number(raw);
        if ((raw.startsWith('{') && raw.endsWith('}')) || (raw.startsWith('[') && raw.endsWith(']'))) {
            try { return JSON.parse(raw); }
            catch { GameAssist.log('Config', 'Invalid JSON: ' + _sanitize(raw)); }
        }
        return raw;
    }
    // --- Notes & Comments ---
    // CHOICE: Gracefully log bad JSON rather than throwing; keeps chat usable.
    // [GAMEASSIST_GAMEASSIST:CORE:STATE] END
    // =============================================================================

    // ————— GameAssist CORE —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:CORE:OBJECT] BEGIN
    // Section Title: GameAssist kernel object
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "CORE:OBJECT", title: "Kernel",
    //   guarantees: ["Logging, error handling, register/enable/disable, listener mgmt"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    const GameAssist = {
        _metrics: {
            commands: 0,
            messages: 0,
            errors: 0,
            stateAudits: 0,
            taskDurations: [],
            lastUpdate: null
        },
        _plannedEvents: [],
        _plannedChatPrefixes: [],
        _listeners: {},
        _commandHandlers: {},
        _eventHandlers: {},
        _transitioning,
        config: {},
        flags: { DEBUG_COMPAT: false, QUIET_STARTUP: true },

        log(mod, msg, level = 'INFO', { startup = false } = {}) {
            if (startup && GameAssist.flags.QUIET_STARTUP) return;

            const timestamp = new Date().toLocaleTimeString();
            const levelIcon = { INFO: 'ℹ️', WARN: '⚠️', ERROR: '❌' }[level] || 'ℹ️';

            // escape user-supplied text, then split on newlines
            const safe = _sanitize(msg).split('\n');

            // prepend /w gm to every continuation line so Roll20 treats
            // the whole block as one whisper
            const stitched = safe.map((l, i) => (i ? '/w gm ' + l : l)).join('\n');

            sendChat(
                'GameAssist',
                `/w gm ${levelIcon} [${timestamp}] [${mod}] ${stitched}`
            );
        },

        handleError(mod, err) {
            this._metrics.errors++;
            this._metrics.lastUpdate = new Date().toISOString();
            this.log(mod, err.message || String(err), 'ERROR');
        },

        register(name, initFn, { enabled = true, events = [], prefixes = [], teardown = null, dependsOn = [] } = {}) {
            if (READY) {
                this.log('Core', `Cannot register after ready: ${name}`, 'WARN');
                return;
            }
            if (MODULES[name]) {
                this.log('Core', `Duplicate module: ${name}`, 'WARN');
                return;
            }
            MODULES[name] = {
                initFn,
                teardown,
                enabled,
                initialized: false,
                active: false,
                events,
                prefixes,
                dependsOn,
                wired: false,
                internal: false
            };
            this._plannedEvents.push(...events);
            this._plannedChatPrefixes.push(...prefixes);
        },

        onCommand(prefix, fn, mod, { gmOnly = false, acl = [] } = {}) {
            const wrapped = msg => {
                if (!MODULES[mod]?.initialized || !MODULES[mod]?.active) return;
                if (msg.type !== 'api' || !msg.content.startsWith(prefix)) return;
                if (gmOnly && !playerIsGM(msg.playerid)) return;
                if (acl.length && !acl.includes(msg.playerid)) return;
                this._metrics.commands++;
                this._metrics.lastUpdate = new Date().toISOString();
                try { fn(msg); }
                catch(e) { this.handleError(mod, e); }
            };
            on('chat:message', wrapped);
            this._commandHandlers[mod] = (this._commandHandlers[mod] || []).concat({ event:'chat:message', fn:wrapped });
        },

        offCommands(mod) {
            this._commandHandlers[mod] = [];
        },

        onEvent(evt, fn, mod) {
            const wrapped = (...args) => {
                if (!MODULES[mod]?.initialized || !MODULES[mod]?.active) return;
                if (!READY) return;
                this._metrics.messages++;
                this._metrics.lastUpdate = new Date().toISOString();
                try { fn(...args); }
                catch(e) { this.handleError(mod, e); }
            };
            on(evt, wrapped);
            this._listeners[mod] = (this._listeners[mod] || []).concat({ event:evt, fn:wrapped });
        },

        offEvents(mod) {
            this._listeners[mod] = [];
        },

        _clearAllListeners() {
            this._commandHandlers = {};
            this._listeners = {};
        },

        _dedupePlanned() {
            if (this._deduped) return;
            this._plannedEvents = [...new Set(this._plannedEvents)];
            this._plannedChatPrefixes = [...new Set(this._plannedChatPrefixes)];
            this._deduped = true;
        },

        enableModule(name) {
            const mod = MODULES[name];
            if (!mod) {
                this.log('Core', `No such module: ${name}`, 'WARN');
                return;
            }
            if (mod.internal) {
                this.log('Core', `${name} is managed by the core and cannot be toggled.`, 'WARN');
                return;
            }
            if (mod.active && mod.initialized) {
                this.log('Core', `${name} already enabled`, 'INFO');
                return;
            }
            if (_transitioning[name]) {
                this.log('Core', `${name} is already transitioning`, 'WARN');
                return;
            }
            _transitioning[name] = true;

            _enqueue(() => {
                const m = MODULES[name];
                const finish = () => { delete _transitioning[name]; };
                if (!m) { finish(); return; }

                const branch = getState(name);
                branch.config.enabled = true;
                branch.runtime = branch.runtime || {};

                if (!m.wired) {
                    try {
                        m.initFn();
                        m.wired = true;
                    } catch (e) {
                        m.initialized = false;
                        m.active = false;
                        branch.config.enabled = false;
                        finish();
                        this.handleError(name, e);
                        return;
                    }
                }

                m.initialized = true;
                m.active = true;
                this._metrics.lastUpdate = new Date().toISOString();
                this.log(name, 'Enabled');
                finish();
            });
        },

        disableModule(name) {
            const mod = MODULES[name];
            if (!mod) {
                this.log('Core', `No such module: ${name}`, 'WARN');
                return;
            }
            if (mod.internal) {
                this.log('Core', `${name} is managed by the core and cannot be toggled.`, 'WARN');
                return;
            }
            if (!mod.active && !mod.initialized) {
                this.log('Core', `${name} already disabled`, 'INFO');
                return;
            }
            if (_transitioning[name]) {
                this.log('Core', `${name} is already transitioning`, 'WARN');
                return;
            }
            _transitioning[name] = true;

            _enqueue(() => {
                const m = MODULES[name];
                const finish = () => { delete _transitioning[name]; };
                if (!m) { finish(); return; }

                if (typeof m.teardown === 'function' && m.wired) {
                    try { m.teardown(); }
                    catch(e) { this.log(name, `Teardown failed: ${e.message}`, 'WARN'); }
                }

                const branch = getState(name);
                branch.config.enabled = false;
                branch.runtime = {};

                m.active = false;
                m.initialized = false;
                this._metrics.lastUpdate = new Date().toISOString();
                this.log(name, 'Disabled');
                finish();
            });
        }
    };

    GameAssist.getState = getState;
    GameAssist.saveState = saveState;
    GameAssist.clearState = clearState;
    GameAssist.getLinkedCharacter = getLinkedCharacter;

    globalThis.GameAssist = GameAssist;
    // --- Notes & Comments ---
    // CHOICE: Expose globally under same name for console and other scripts.
    // [GAMEASSIST_GAMEASSIST:CORE:OBJECT] END
    // =============================================================================

    // ————— CONFIG COMMAND —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS] BEGIN
    // Section Title: Admin/config commands (!ga-*)
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "INTERFACES:COMMANDS", title: "Commands",
    //   guarantees: ["GM-gated admin commands; consistent logging"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    GameAssist.onCommand('!ga-config', msg => {
        const parts = msg.content.trim().split(/\s+/);
        const sub   = parts[1];
        if (sub === 'list') {
            const ts   = new Date().toLocaleString();
            const ver  = `v${VERSION}`;
            const cfg  = JSON.stringify(state[STATE_KEY].config, null, 2)
                          .replace(/[<>&]/g, c=>({'<':'&lt;','>':'&gt;','&':'&amp;'})[c]);
            const name = 'GameAssist Config';
            let handout = findObjs({ type:'handout', name })[0];
            if (!handout) handout = createObj('handout', { name, archived:false });
            handout.set('notes', `<pre>Generated: ${ts} (${ver})\n\n${cfg}</pre>`);
            sendChat('GameAssist', `/w gm Config written to "${name}"`);
        }
        else if (sub === 'set' && parts.length >= 4) {
            const mod = parts[2];
            const [ key, ...rest ] = parts.slice(3).join(' ').split('=');
            const val = rest.join('=');
            const parsed = parseConfigValue(val);
            if (!MODULES[mod] || MODULES[mod].internal) {
                GameAssist.log('Config', `Unknown module: ${mod}`, 'WARN');
                return;
            }
            GameAssist.getState(mod).config[key.trim()] = parsed;
            GameAssist.log('Config', `Set ${mod}.${key.trim()} = ${JSON.stringify(parsed)}`);
        }
        else if (sub === 'get' && parts.length >= 4) {
            const mod = parts[2];
            const key = parts[3];
            if (!MODULES[mod] || MODULES[mod].internal) {
                GameAssist.log('Config', `Unknown module: ${mod}`, 'WARN');
                return;
            }
            const val = GameAssist.getState(mod).config[key];
            GameAssist.log('Config', `${mod}.${key} = ${JSON.stringify(val)}`);
        }
        else if (sub === 'modules') {
            const moduleList = Object.entries(MODULES)
                .filter(([, mod]) => !mod.internal)
                .map(([name, mod]) => {
                    const cfg = GameAssist.getState(name).config;
                    const status = cfg.enabled ? '✅' : '❌';
                    const init = mod.initialized && mod.active ? '🟢' : '⏸️';
                    return `${status}${init} ${name}`;
                }).join('\n');
            GameAssist.log('Config', `Modules:\n${moduleList}`);
        }
        else {
            GameAssist.log('Config', 'Usage: !ga-config list|set|get|modules [args]');
        }
    }, 'Core', { gmOnly: true });

    // ————— CONTROL COMMANDS —————
    GameAssist.onCommand('!ga-enable', msg => {
        const mod = msg.content.split(/\s+/)[1];
        if (!mod) {
            GameAssist.log('Core', 'Usage: !ga-enable <module>', 'WARN');
            return;
        }
        GameAssist.enableModule(mod);
    }, 'Core', { gmOnly: true });

    GameAssist.onCommand('!ga-disable', msg => {
        const mod = msg.content.split(/\s+/)[1];
        if (!mod) {
            GameAssist.log('Core', 'Usage: !ga-disable <module>', 'WARN');
            return;
        }
        GameAssist.disableModule(mod);
    }, 'Core', { gmOnly: true });

    GameAssist.onCommand('!ga-status', msg => {
        const metrics = GameAssist._metrics;
        const avgDuration = metrics.taskDurations.length > 0 
            ? (metrics.taskDurations.reduce((a,b) => a+b, 0) / metrics.taskDurations.length).toFixed(2)
            : 'N/A';

        const status = [
            `**GameAssist ${VERSION} Status**`,
            `Commands: ${metrics.commands}`,
            `Messages: ${metrics.messages}`,
            `Errors: ${metrics.errors}`,
            `Avg Task Duration: ${avgDuration}ms`,
            `Queue Length: ${_queue.length}`,
            `Last Update: ${metrics.lastUpdate || 'Never'}`,
            `Modules: ${Object.entries(MODULES).filter(([, m]) => !m.internal).length}`,
            `Active Listeners: ${Object.values(GameAssist._listeners).flat().length}`
        ].join('\n');

        GameAssist.log('Status', status);
    }, 'Core', { gmOnly: true });
    // --- Notes & Comments ---
    // CHOICE: Keep command syntax identical to legacy for drop‑in replacement.
    // [GAMEASSIST_GAMEASSIST:INTERFACES:COMMANDS] END
    // =============================================================================

    // ————— CRITFUMBLE MODULE v0.2.4.9 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE] BEGIN
    // Section Title: CritFumble module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:CRITFUMBLE", title: "CritFumble",
    //   guarantees: ["Behavior unchanged; natural‑1 detection bugfix retained"], version: "0.2.4.9" }
    // -------------------------------------------------------------------------
    GameAssist.register('CritFumble', function() {
        // ─── Module Setup ──────────────────────────────────────────────────────────────
        const modState = GameAssist.getState('CritFumble');
        Object.assign(modState.config, {
            enabled:   true,
            debug:     true,
            useEmojis: true,
            rollDelayMs: 200,
            // Preserve any values previously saved in state
            ...modState.config
        });
        modState.runtime.activePlayers = modState.runtime.activePlayers || {};

        // ─── Constants ─────────────────────────────────────────────────────────────────
        /** Which Roll20 rolltemplates we watch for natural-1s */
        const VALID_TEMPLATES = ['atk','atkdmg','npcatk','spell'];
        const FUMBLE_TABLES = {
            melee:   'CF-Melee',
            ranged:  'CF-Ranged',
            spell:   'CF-Spell',
            natural: 'CF-Natural',
            thrown:  'CF-Thrown'
        };
        // Lookup for confirm tables
        const CONFIRM_TABLES = {
            'confirm-crit-martial': 'Confirm-Crit-Martial',
            'confirm-crit-magic':   'Confirm-Crit-Magic'
        };

        // ─── Helper Functions ──────────────────────────────────────────────────────────
        /**
         * debugLog(msg)
        *   Logs to the GM only when debug mode is on.
        *   Uses GameAssist.log under the hood.
        */
        function debugLog(msg) {
            if (modState.config.debug) {
                GameAssist.log('CritFumble', msg);
            }
        }
        function emoji(sym) {
            return modState.config.useEmojis ? sym : '';
        }

        // Strip off any " (GM)" suffix so /w target resolves
        function sanitizeWho(who) {
            return who.replace(/ \(GM\)$/, '');
        }

        function sendTemplateMessage(who,title,fields) {
            who = sanitizeWho(who);
            const content = fields.map(f=>`{{${f.label}=${f.value}}}`).join(' ');
            sendChat('CritFumble', `/w "${who}" &{template:default} {{name=${title}}} ${content}`);
        }

        function getFumbleTableName(type) {
            return FUMBLE_TABLES[type]||null;
        }

        function sendConfirmMenu(who) {
    const confirmButtons = [
        `[Confirm-Crit-Martial](!Confirm-Crit-Martial)`,
        `[Confirm-Crit-Magic](!Confirm-Crit-Magic)`
    ].join(' ');

    // Send to player
    sendTemplateMessage(who, `${emoji('❓')} Confirm Critical Miss`, [
        { label: "Choose Confirmation Type", value: confirmButtons }
    ]);
    // Also send to GM
    sendTemplateMessage('gm', `${emoji('❓')} Confirm Critical Miss for ${who}!`, [
        { label: "Choose Confirmation Type", value: confirmButtons }
    ]);
}

        function sendFumbleMenu(who) {
            sendConfirmMenu(who);
            const buttons = [
                `[⚔ Melee](!critfumble-melee)`,
                `[🏹 Ranged](!critfumble-ranged)`,
                `[🎯 Thrown](!critfumble-thrown)`,
                `[🔥 Spell](!critfumble-spell)`,
                `[👊 Natural/Unarmed](!critfumble-natural)`
            ].join(' ');
            sendTemplateMessage(who, `${emoji('💥')} Critical Miss!`, [
                { label: "What kind of attack was this?", value: buttons }
            ]);
            // also whisper to GM for awareness
            sendTemplateMessage('gm', `${emoji('💥')} Critical Miss for ${who}!`, [
                { label: "What kind of attack was this?", value: buttons }
            ]);
        }

        function announceTableRoll(tableName) {
            sendTemplateMessage('gm', `${emoji('🎲')} Rolling Table`, [
                { label: "Table", value: `**${tableName}**` }
            ]);
        }
        function executeTableRoll(tableName) {
            setTimeout(()=>{
                sendChat('', `/roll 1t[${tableName}]`);
                debugLog(`Roll command executed: /roll 1t[${tableName}]`);
            }, modState.config.rollDelayMs);
        }

        function rollFumbleTable(who,type) {
            const table = getFumbleTableName(type);
            if (!table) {
                sendTemplateMessage(who, "⚠️ Invalid Fumble Type", [
                    { label: "Requested",    value: `"${type}"` },
                    { label: "Valid Types",  value: Object.keys(FUMBLE_TABLES).join(', ') }
                ]);
                debugLog(`Invalid fumble type "${type}"`);
                return;
            }
            announceTableRoll(table);
            executeTableRoll(table);
        }

        function rollConfirmTable(who,rawCommand) {
            const table = CONFIRM_TABLES[rawCommand.toLowerCase()];
            if (!table) {
                sendTemplateMessage(who, "⚠️ Invalid Confirm Type", [
                    { label: "Requested",     value: `"${rawCommand}"` },
                    { label: "Valid Options", value: Object.values(CONFIRM_TABLES).join(', ') }
                ]);
                debugLog(`Invalid confirm type "${rawCommand}"`);
                return;
            }
            announceTableRoll(table);
            executeTableRoll(table);
        }

        function hasNaturalOne(inlinerolls) {
    for (const group of inlinerolls) {
        if (!group || !group.results || !Array.isArray(group.results.rolls)) continue;
        for (const roll of group.results.rolls) {
            // Only look at d20 dice rolls
            if (roll.type !== 'R' || roll.sides !== 20 || !Array.isArray(roll.results)) continue;
            for (const result of roll.results) {
                // Defensive: result must have .v (value); .r is not always present
                if (typeof result.v !== 'number') continue;
                if (result.v === 1) return true;
            }
        }
    }
    return false;
}

        function showManualTriggerMenu() {
            const players = Object.values(modState.runtime.activePlayers);
            if (!players.length) {
                sendTemplateMessage('gm', "⚠️ No Players Detected", [
                    { label:"Note", value:"No players have been active yet this session." }
                ]);
                return;
            }
            const buttons = players.map(name=>
                `[${name}](!critfumblemenu-${encodeURIComponent(name)})`
            ).join(' ');
            sendTemplateMessage('gm',"Manually Trigger Fumble Menu",[
                { label:"Select Player", value:buttons }
            ]);
        }

        function handleManualTrigger(encodedName) {
            sendFumbleMenu(decodeURIComponent(encodedName));
            debugLog(`Manually triggered fumble menu for: ${encodedName}`);
        }

        function showHelpMessage(who) {
            sendTemplateMessage(who, "📘 CritFumble Help", [
                { label: "Version",     value: "v0.2.4.9" },
                { label: "Commands",    value: "`!critfail`, `!critfumble help`, `!critfumble-<type>`, `!confirm-crit-martial`, `!confirm-crit-magic`" },
                { label: "Description", value: "Auto-detects critical misses and prompts attacker with a fumble menu; GM can also manually trigger via `!critfail`." },
                { label: "Valid Types", value: Object.keys(FUMBLE_TABLES).join(', ') }
            ]);
        }

        function handleRoll(msg) {
            if (!msg) return;
            // register active players
            if (msg.playerid && !modState.runtime.activePlayers[msg.playerid]) {
                const p = getObj('player', msg.playerid);
                if (p) modState.runtime.activePlayers[msg.playerid] = p.get('displayname');
            }

            // API‐style commands
            if (msg.type==='api') {
                const cmd = (msg.content||'').trim().toLowerCase();

                if (cmd==='!critfail') {
                    debugLog('Manual trigger: !critfail');
                    return showManualTriggerMenu();
                }
                if (cmd==='!critfumble help') {
                    return showHelpMessage(msg.who);
                }
                if (cmd.startsWith('!critfumblemenu-')) {
                    return handleManualTrigger(msg.content.replace('!critfumblemenu-',''));
                }
                if (cmd.startsWith('!critfumble-')) {
                    const who        = sanitizeWho(msg.who);
                    const fumbleType = msg.content.replace('!critfumble-','').toLowerCase();
                    debugLog(`${who} selected fumble type: ${fumbleType}`);
                    return rollFumbleTable(who, fumbleType);
                }
                if (cmd.startsWith('!confirm-crit-')) {
                    const who        = sanitizeWho(msg.who);
                    const rawCommand = msg.content.slice(1);  // e.g. "confirm-crit-martial"
                    debugLog(`${who} selected confirm type: ${rawCommand}`);
                    return rollConfirmTable(who, rawCommand);
                }
                return;
            }

            // auto-detect natural 1 on a valid rolltemplate
            if (!msg.rolltemplate || !VALID_TEMPLATES.includes(msg.rolltemplate)) return;
            const rolls = msg.inlinerolls||[];
            if (!hasNaturalOne(rolls)) return;

            const who = sanitizeWho(msg.who);
            debugLog(`Fumble detected from: ${who}`);
            sendFumbleMenu(who);
        }

        GameAssist.onEvent('chat:message', handleRoll, 'CritFumble');
        GameAssist.log('CritFumble','v0.2.4.9 Ready: Auto fumble detection + !critfail','INFO',{startup:true});
    }, {
        enabled: true,
        events:   ['chat:message'],
        prefixes: ['!critfail','!critfumble']
    });
    // --- Notes & Comments ---
    // Bugfix retained: robust natural‑1 detection across templates/inlineroll variants.
    // [GAMEASSIST_GAMEASSIST:MODULES:CRITFUMBLE] END
    // =============================================================================

    // ————— NPC MANAGER MODULE v0.1.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER] BEGIN
    // Section Title: NPCManager module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:NPCMANAGER", title: "NPCManager",
    //   guarantees: ["Auto toggle dead marker based on HP"], version: "0.1.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('NPCManager', function() {
        const modState = GameAssist.getState('NPCManager');

        Object.assign(modState.config, {
            enabled: true,
            autoTrackDeath: true,
            deadMarker: 'dead',
            ...modState.config
        });

        function getNPCContext(token, link = null) {
            const linked = link || GameAssist.getLinkedCharacter(token);
            if (!linked) return null;

            const npcAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc'
            })[0];

            if (!npcAttr || npcAttr.get('current') !== '1') return null;
            return linked;
        }

        function checkForDeath(token) {
            if (!modState.config.autoTrackDeath) return;

            if (!getNPCContext(token)) return;

            const hp = parseInt(token.get('bar1_value'), 10) || 0;
            const markers = (token.get('statusmarkers') || '').split(',');
            const isDead = markers.includes(modState.config.deadMarker);

            if (hp < 1 && !isDead) {
                sendChat('api', `!token-mod --ids ${token.id} --set statusmarkers|+${modState.config.deadMarker}`);
                GameAssist.log('NPCManager', `${token.get('name')} marked as dead (HP: ${hp})`);
            } else if (hp >= 1 && isDead) {
                sendChat('api', `!token-mod --ids ${token.id} --set statusmarkers|-${modState.config.deadMarker}`);
                GameAssist.log('NPCManager', `${token.get('name')} revived (HP: ${hp})`);
            }
        }

        function handleTokenChange(obj, prev) {
            if (obj.get('bar1_value') !== prev.bar1_value) {
                checkForDeath(obj);
            }
        }

        GameAssist.onCommand('!npc-death-report', msg => {
            const pageId = Campaign().get('playerpageid');
            const tokens = findObjs({
                _pageid: pageId,
                _type: 'graphic',
                layer: 'objects'
            });

            const flagged = [];
            const invalid = [];
            for (let token of tokens) {
                const link = GameAssist.getLinkedCharacter(token);
                if (!link) {
                    invalid.push(token.get('name') || '(Unnamed)');
                    continue;
                }

                if (!getNPCContext(token, link)) continue;

                const hp = parseInt(token.get('bar1_value'), 10) || 0;
                const markers = (token.get('statusmarkers') || '').split(',');
                const isDead = markers.includes(modState.config.deadMarker);

                if ((hp < 1 && !isDead) || (hp >= 1 && isDead)) {
                    flagged.push({
                        name: token.get('name') || '(Unnamed)',
                        id: token.id,
                        hp,
                        markers: token.get('statusmarkers') || '(none)'
                    });
                }
            }

            if (flagged.length === 0) {
                GameAssist.log('NPCManager', '✅ Living NPCs have correct death marker states.');
            } else {
                GameAssist.log('NPCManager', `⚠️ ${flagged.length} NPC(s) with mismatched death markers:`);
                flagged.forEach(({ name, id, hp, markers }) => {
                    GameAssist.log('NPCManager', `- ${name} [${id}] | HP: ${hp} | Markers: ${markers}`);
                });
            }

            if (invalid.length) {
                GameAssist.log(
                    'NPCManager',
                    `Skipped ${invalid.length} token(s) with no linked character: ${invalid.join(', ')}`,
                    'WARN'
                );
            }
        }, 'NPCManager', { gmOnly: true });

        GameAssist.onEvent('change:graphic:bar1_value', handleTokenChange, 'NPCManager');
        GameAssist.log('NPCManager', 'v0.1.1.0 Ready: Auto death tracking + !npc-death-report', 'INFO', { startup: true });
    }, { 
        enabled: true, 
        events: ['change:graphic:bar1_value'], 
        prefixes: ['!npc-death-report'] 
    });
    // --- Notes & Comments ---
    // CHOICE: TokenMod used for status marker ops; keep dependency explicit in README.
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCMANAGER] END
    // =============================================================================

// ————— CONCENTRATION TRACKER MODULE v0.1.0.5 —————
// =============================================================================
// [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER] BEGIN
// Section Title: ConcentrationTracker module
// -------------------------------------------------------------------------
// mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:CONCENTRATIONTRACKER", title: "ConcentrationTracker",
//   guarantees: ["Chat UI for concentration saves; TokenMod marker toggle"], version: "0.1.0.5" }
// -------------------------------------------------------------------------
GameAssist.register('ConcentrationTracker', function() {
    // ─── Module Setup ──────────────────────────────────────────────────────────────
    const modState = GameAssist.getState('ConcentrationTracker');
    Object.assign(modState.config, {
        enabled:   true,
        marker:    'Concentrating',
        randomize: true,
        ...modState.config
    });
    modState.runtime.lastDamage = modState.runtime.lastDamage || {};

    // ─── Public Command Prefixes ───────────────────────────────────────────────────
    const CMDS = ['!concentration', '!cc'];
    const TOKEN_MARKER = 'Concentrating';

    // ─── Default Emote Lines ────────────────────────────────────────────────────────
    const DEFAULT_LINES = {
        success: [
            "steadies their breath, holding their focus.",
            "'s grip tightens as they maintain their spell.",
            "staggers slightly but does not lose concentration.",
            "clenches their jaw, magic still flickering with intent.",
            "narrows their eyes, spell still intact."
        ],
        failure: [
            "gasps, their focus shattered as the spell falters.",
            "'s concentration breaks and the magic fades.",
            "cries out, unable to maintain the spell.",
            "'s spell fizzles as they lose control.",
            "winces, focus lost in the heat of battle."
        ]
    };

    // ─── Helper Functions ──────────────────────────────────────────────────────────

    /**
     * getConfig()
     *   Merge default settings with stored config.
     */
    function getConfig() {
        return Object.assign({ randomize: true }, modState.config);
    }

    /**
     * getOutcomeLines(name)
     *   Returns the success/failure emote arrays with {{name}} replaced.
     */
    function getOutcomeLines(name) {
        const fill = line => line.replace("{{name}}", name);
        return {
            success: DEFAULT_LINES.success.map(fill),
            failure: DEFAULT_LINES.failure.map(fill)
        };
    }

    /**
     * getConBonus(character)
     *   Reads the character's Constitution saving throw bonus.
     */
    function getConBonus(character) {
        const attr = findObjs({
            _type:       'attribute',
            _characterid: character.id,
            name:        'constitution_save_bonus'
        })[0];
        return attr ? parseInt(attr.get('current'), 10) : 0;
    }

    /**
     * toggleMarker(token, on)
     *   Adds or removes the Concentrating status marker.
     */
    function toggleMarker(token, on) {
        sendChat('api',
            `!token-mod --ids ${token.id} --set statusmarkers|${on ? '+' : '-'}${TOKEN_MARKER}`
        );
    }

    /**
     * postButtons(recipient)
     *   Sends the three-button UI for a new concentration check.
     */
    function postButtons(recipient) {
        const dmg = '?{Damage taken?|0}';
        const buttons = [
            `[🎯 Maintain Control](!concentration --damage ${dmg} --mode normal)`,
            `[🧠 Brace for the Distraction](!concentration --damage ${dmg} --mode adv)`,
            `[😣 Struggling to Focus](!concentration --damage ${dmg} --mode dis)`
        ].join(' ');
        sendChat('ConcentrationTracker',
            `/w "${recipient}" ${buttons}<br>⚠️ Select your token before clicking.`
        );
    }

    /**
     * sendResult(player, dc, total, rolls, formula)
     *   Whispers the concentration-check result to player & GM.
     */
    function sendResult(player, dc, total, rolls, formula) {
        const tpl =
            `&{template:default} {{name=🧠 Concentration Check}}` +
            ` {{DC=${dc}}} {{Result=Roll(s) ${rolls} → ${total} (from ${formula})}}`;
        sendChat('ConcentrationTracker', `/w "${player}" ${tpl}`);
        sendChat('ConcentrationTracker', `/w gm ${tpl}`);
    }

    /**
     * showStatus(player)
     *   Lists all tokens currently marked Concentrating.
     */
    function showStatus(player) {
        const page = Campaign().get('playerpageid');
        const tokens = findObjs({
            _type:  'graphic',
            _pageid: page,
            layer:  'objects'
        }).filter(t =>
            (t.get('statusmarkers') || '')
                .toLowerCase()
                .includes(TOKEN_MARKER.toLowerCase())
        );
        if (!tokens.length) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" No tokens concentrating.`
            );
        }
        let out = `&{template:default} {{name=🧠 Concentration Status}}`;
        tokens.forEach(t => {
            out += `{{${t.get('name') || 'Unnamed'}=Concentrating}}`;
        });
        sendChat('ConcentrationTracker', `/w "${player}" ${out}`);
    }

    /**
     * showHelp(player)
     *   Whisper the full list of commands and usage.
     */
    function showHelp(player) {
        const helpText = [
            "🧠 Concentration Help:",
            "• !concentration / !cc → Show buttons",
            "• --damage X           → Roll vs DC = max(10,⌊X/2⌋)",
            "• --mode normal|adv|dis→ Set roll mode",
            "• --last               → Repeat last check",
            "• --off                → Remove marker from selected tokens",
            "• --status             → Who is concentrating",
            "• --config randomize on|off → Toggle emote randomization"
        ].join('<br>');
        sendChat('ConcentrationTracker', `/w "${player}" ${helpText}`);
    }

    /**
     * handleRoll(msg, damage, mode)
     *   Executes the concentration roll workflow.
     */
    function handleRoll(msg, damage, mode) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        if (!msg.selected?.length) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ No token selected.`
            );
        }
        const token = getObj('graphic', msg.selected[0]._id);
        if (!token) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ Token not found.`
            );
        }

        const linked = GameAssist.getLinkedCharacter(token);
        if (!linked) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ Token must be on the Objects layer and linked to a character.`
            );
        }

        const { character } = linked;

        const bonus = getConBonus(character);
        const dc    = Math.max(10, Math.floor(damage / 2));
        const name  = token.get('name') || character.get('name');
        const { success: S, failure: F } = getOutcomeLines(name);
        const { randomize } = getConfig();

        let expr = `1d20 + ${bonus}`;
        if (mode === 'adv') expr = `2d20kh1 + ${bonus}`;
        if (mode === 'dis') expr = `2d20kl1 + ${bonus}`;

        modState.runtime.lastDamage[msg.playerid] = damage;

        sendChat('', `[[${expr}]]`, ops => {
            const roll = ops[0].inlinerolls?.[0];
            if (!roll) {
                return sendChat('ConcentrationTracker',
                    `/w "${player}" ⚠️ Roll failed.`
                );
            }
            const total   = roll.results.total;
            const formula = roll.expression;
            const vals    = roll.results.rolls[0].results.map(r => r.v);
            const rollsText = (mode === 'normal' ? vals[0] : vals.join(','));
            const ok        = total >= dc;

            sendResult(player, dc, total, rollsText, formula);

            const pool = ok ? S : F;
            const tail = randomize
                ? pool[Math.floor(Math.random() * pool.length)]
                : pool[0];
            sendChat(`character|${character.id}`, `/em ${tail}`);
            toggleMarker(token, ok);
        });
    }

    /**
     * handleClear(msg)
     *   Clears the marker from selected tokens.
     */
    function handleClear(msg) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        const skipped = [];

        msg.selected?.forEach(sel => {
            const t = getObj('graphic', sel._id);
            if (!t) {
                skipped.push('(Missing Token)');
                return;
            }

            if (!GameAssist.getLinkedCharacter(t)) {
                skipped.push(t.get('name') || '(Unnamed)');
                return;
            }

            toggleMarker(t, false);
        });

        let response = '✅ Cleared markers.';
        if (skipped.length) {
            response += ` Skipped: ${skipped.join(', ')}.`;
        }

        sendChat('ConcentrationTracker', `/w "${player}" ${response}`);
    }

    /**
     * handleLast(msg)
     *   Repeats the last concentration check.
     */
    function handleLast(msg) {
        const player = msg.who.replace(/ \(GM\)$/, '');
        const dmg    = modState.runtime.lastDamage[msg.playerid];
        if (!dmg) {
            return sendChat('ConcentrationTracker',
                `/w "${player}" ⚠️ No previous damage.`
            );
        }
        handleRoll(msg, dmg, 'normal');
    }

    // ─── Core Handler (Case-Insensitive) ──────────────────────────────────────────
    function handler(msg) {
        if (msg.type !== 'api') return;

        // 1) Normalize prefix: trim + lowercase
        const raw   = msg.content.trim();
        const parts = raw.toLowerCase().split(/\s+--/);
        const cmd   = parts.shift();             // "!concentration" or "!cc"
        if (!CMDS.includes(cmd)) return;

        // 2) Identify player (strip " (GM)")
        const player = msg.who.replace(/ \(GM\)$/, '');

        // 3) Config branch
        if (parts[0]?.startsWith('config ')) {
            const [, key, val] = parts[0].split(/\s+/);
            if (key === 'randomize') {
                modState.config.randomize = (val === 'on' || val === 'true');
                return sendChat('ConcentrationTracker',
                    `/w "${player}" ✅ Randomize = ${modState.config.randomize}`
                );
            }
            return sendChat('ConcentrationTracker',
                `/w "${player}" ❌ Unknown config ${key}`
            );
        }

        // 4) Parse flags
        let damage = 0, mode = 'normal';
        for (let p of parts) {
            if (p === 'help')   return showHelp(player);
            if (p === 'status') return showStatus(player);
            if (p === 'last')   return handleLast(msg);
            if (p === 'off')    return handleClear(msg);
            if (p.startsWith('damage ')) damage = parseInt(p.split(' ')[1], 10);
            if (p.startsWith('mode '))   mode   = p.split(' ')[1];
        }

        // 5) Execute
        if (damage > 0) {
            handleRoll(msg, damage, mode);
        } else {
            postButtons(player);
        }
    }

    // ─── Wire It Up ────────────────────────────────────────────────────────────────
    GameAssist.onEvent('chat:message', handler, 'ConcentrationTracker');
    GameAssist.log(
        'ConcentrationTracker',
        `Ready: ${CMDS.join(' & ')}`,
        'INFO',
        { startup: true }
    );
}, {
    enabled:  true,
    prefixes: ['!concentration','!cc'],
    teardown: () => {
        const page = Campaign().get('playerpageid');
        findObjs({ _type: 'graphic', _pageid: page, layer: 'objects' })
            .filter(t =>
                (t.get('statusmarkers') || '')
                    .toLowerCase()
                    .includes('concentrating')
            )
            .forEach(t =>
                sendChat('api',
                    `!token-mod --ids ${t.id} --set statusmarkers|-Concentrating`
                )
            );
    }
});
// --- Notes & Comments ---
// CHOICE: Keep lowercase parsing and aliases exactly as legacy; avoids user retraining.
// [GAMEASSIST_GAMEASSIST:MODULES:CONCENTRATIONTRACKER] END
// =============================================================================

    // ————— NPC HP ROLLER MODULE v0.1.1.0 —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER] BEGIN
    // Section Title: NPCHPRoller module
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "MODULES:NPCHPROLLER", title: "NPCHPRoller",
    //   guarantees: ["Parse NdM±K and set bar1 to rolled HP"], version: "0.1.1.0" }
    // -------------------------------------------------------------------------
    GameAssist.register('NPCHPRoller', function() {
        const modState = GameAssist.getState('NPCHPRoller');

    Object.assign(modState.config, {
        enabled: true,
        autoRollOnAdd: false,
        ...modState.config
    });

        function parseDiceString(diceStr) {
            // Match “NdM”, “NdM+K”, “NdM + K”, “NdM-K”, case-insensitive on “d”
            const match = diceStr.match(
                /^\s*(\d+)\s*[dD]\s*(\d+)(?:\s*([+-])\s*(\d+))?\s*$/
            );
            if (!match) return null;

            const count = parseInt(match[1], 10);
            const sides = parseInt(match[2], 10);
            const sign  = match[3] === '-' ? -1 : 1;
            const bonus = match[4] ? sign * parseInt(match[4], 10) : 0;

            return { count, sides, bonus };
        }

        function rollDice(count, sides) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * sides) + 1;
            }
            return total;
        }

        function rollHP(diceData) {
            const { count, sides, bonus } = diceData;
            return rollDice(count, sides) + bonus;
        }

        function rollTokenHP(token) {
            if (!token) {
                GameAssist.log('NPCHPRoller', 'Token not found', 'WARN');
                return;
            }

            const linked = GameAssist.getLinkedCharacter(token);
            if (!linked) {
                GameAssist.log('NPCHPRoller', `${token.get('name') || 'Token'} must be linked to a character on the Objects layer.`, 'WARN');
                return;
            }

            const npcAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc'
            })[0];

            if (!npcAttr || npcAttr.get('current') !== '1') {
                GameAssist.log('NPCHPRoller', `${token.get('name') || linked.character.get('name')} is not flagged as an NPC.`, 'WARN');
                return;
            }

            const hpFormulaAttr = findObjs({
                _type: 'attribute',
                _characterid: linked.character.id,
                name: 'npc_hpformula'
            })[0];

            if (!hpFormulaAttr) {
                GameAssist.log('NPCHPRoller', `No HP formula found for ${token.get('name') || linked.character.get('name')}`, 'WARN');
                return;
            }

            const formula = hpFormulaAttr.get('current');
            const diceData = parseDiceString(formula);

            if (!diceData) {
                GameAssist.log('NPCHPRoller', `Invalid HP formula: ${formula}`, 'WARN');
                return;
            }

            const hp = rollHP(diceData);

            token.set('bar1_value', hp);
            token.set('bar1_max', hp);

            GameAssist.log('NPCHPRoller', `${token.get('name')} HP set to ${hp} using [${formula}]`);
        }

        GameAssist.onCommand('!npc-hp-all', async msg => {
            const pageId = Campaign().get('playerpageid');
            const tokens = findObjs({
                _pageid: pageId,
                _type: 'graphic',
                layer: 'objects'
            });

            const npcTokens = [];
            const skipped = [];

            for (const token of tokens) {
                const link = GameAssist.getLinkedCharacter(token);
                if (!link) {
                    skipped.push(token.get('name') || '(Unnamed)');
                    continue;
                }

                const npcAttr = findObjs({
                    _type: 'attribute',
                    _characterid: link.character.id,
                    name: 'npc'
                })[0];

                if (npcAttr && npcAttr.get('current') === '1') {
                    npcTokens.push(token);
                }
            }

            GameAssist.log('NPCHPRoller', `Rolling HP for ${npcTokens.length} NPCs on current map...`);

            for (const token of npcTokens) {
                try {
                    rollTokenHP(token);
                } catch (err) {
                    GameAssist.log('NPCHPRoller', `Error processing ${token.get('name')}: ${err.message}`, 'ERROR');
                }
            }

            if (skipped.length) {
                GameAssist.log('NPCHPRoller', `Skipped ${skipped.length} token(s) without linked characters: ${skipped.join(', ')}`, 'WARN');
            }
        }, 'NPCHPRoller', { gmOnly: true });

        GameAssist.onCommand('!npc-hp-selected', msg => {
            if (!msg.selected || msg.selected.length === 0) {
                GameAssist.log('NPCHPRoller', 'No tokens selected', 'WARN');
                return;
            }

            const skipped = [];

            msg.selected.forEach(sel => {
                const token = getObj('graphic', sel._id);
                if (!token) {
                    skipped.push('(Missing Token)');
                    return;
                }

                if (!GameAssist.getLinkedCharacter(token)) {
                    skipped.push(token.get('name') || '(Unnamed)');
                    return;
                }

                try {
                    rollTokenHP(token);
                } catch (err) {
                    GameAssist.log('NPCHPRoller', `Error processing ${token.get('name')}: ${err.message}`, 'ERROR');
                }
            });

            if (skipped.length) {
                GameAssist.log('NPCHPRoller', `Skipped ${skipped.length} token(s): ${skipped.join(', ')}`, 'WARN');
            }
        }, 'NPCHPRoller', { gmOnly: true });

        GameAssist.log('NPCHPRoller', 'v0.1.1.0 Ready: !npc-hp-all, !npc-hp-selected', 'INFO', { startup: true });
    }, { 
        enabled: true, 
        events: [], 
        prefixes: ['!npc-hp-all', '!npc-hp-selected'] 
    });
    // --- Notes & Comments ---
    // CHOICE: Use Math.random for simplicity; acceptable for non‑critical HP rolls.
    // [GAMEASSIST_GAMEASSIST:MODULES:NPCHPROLLER] END
    // =============================================================================

    // ————— BOOTSTRAP —————
    // =============================================================================
    // [GAMEASSIST_GAMEASSIST:BOOTSTRAP] BEGIN
    // Section Title: Sandbox ready bootstrap
    // -------------------------------------------------------------------------
    // mechsuit_section: { codename: "GAMEASSIST_GAMEASSIST", area: "BOOTSTRAP", title: "Bootstrap",
    //   guarantees: ["Seed defaults, audit state, init enabled modules"], version: "1.0.0" }
    // -------------------------------------------------------------------------
    on('ready', () => {
        if (READY) return;
        READY = true;

        state[STATE_KEY] = state[STATE_KEY] || { config: {} };
        GameAssist.config = state[STATE_KEY].config;

        GameAssist._clearAllListeners();
        seedDefaults();
        auditState();
        GameAssist._dedupePlanned();
        auditCompatibility();

        const moduleNames = Object.entries(MODULES)
            .filter(([, mod]) => !mod.internal)
            .map(([name]) => name);

        GameAssist.log('Core', `GameAssist v${VERSION} ready; modules: ${moduleNames.join(', ')}`);

        moduleNames.forEach(name => {
            const mod = MODULES[name];
            const cfg = getState(name).config;

            if (cfg.enabled) {
                try {
                    if (!mod.wired) {
                        mod.initFn();
                        mod.wired = true;
                    }
                    mod.initialized = true;
                    mod.active = true;
                } catch (e) {
                    mod.initialized = false;
                    mod.active = false;
                    GameAssist.handleError(name, e);
                }
            } else {
                mod.initialized = false;
                mod.active = false;
            }
        });

        GameAssist._metrics.lastUpdate = new Date().toISOString();
    });
    // --- Notes & Comments ---
    // CHOICE: Core ready log is never suppressed; mirrors README guidance.
    // [GAMEASSIST_GAMEASSIST:BOOTSTRAP] END
    // =============================================================================

})();

// --- Notes & Comments ---
// Parent wrapper: No behavior changes. This mechsuit only adds structure and documentation.
// Prior notes (selected):
//   • MIT license retained; copyright © 2025 Mord Eagle.
//   • Modules: CritFumble, NPCManager, ConcentrationTracker, NPCHPRoller.
//   • Queue/watchdog defaults preserved (30s/15s).
//   • Logging emits /w gm with icons and timestamp.
// [GAMEASSIST_GAMEASSIST:APP] END
// ============================================================================
